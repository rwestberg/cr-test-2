<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/continuation.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
  79 #include &quot;runtime/threadSMR.hpp&quot;
  80 #include &quot;runtime/vframe.inline.hpp&quot;
  81 #include &quot;runtime/vmOperations.hpp&quot;
  82 #include &quot;runtime/vm_version.hpp&quot;
  83 #include &quot;services/attachListener.hpp&quot;
  84 #include &quot;services/management.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/copy.hpp&quot;
  87 #include &quot;utilities/defaultStream.hpp&quot;
  88 #include &quot;utilities/dtrace.hpp&quot;
  89 #include &quot;utilities/events.hpp&quot;
  90 #include &quot;utilities/histogram.hpp&quot;
  91 #include &quot;utilities/macros.hpp&quot;
  92 #include &quot;utilities/utf8.hpp&quot;
  93 #if INCLUDE_CDS
  94 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  95 #endif
  96 #if INCLUDE_JFR
  97 #include &quot;jfr/jfr.hpp&quot;
  98 #endif
  99 
 100 #include &lt;errno.h&gt;
 101 
 102 /*
 103   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 104   such ctors and calls MUST NOT come between an oop declaration/init and its
 105   usage because if objects are move this may cause various memory stomps, bus
 106   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 107   failures&quot;:
 108 
 109       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 110           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 111 
 112           // Object address to be held directly in mirror &amp; not visible to GC
 113           oop mirror = JNIHandles::resolve_non_null(ofClass);
 114 
 115           // If this ctor can hit a safepoint, moving objects around, then
 116           ComplexConstructor foo;
 117 
 118           // Boom! mirror may point to JUNK instead of the intended object
 119           (some dereference of mirror)
 120 
 121           // Here&#39;s another call that may block for GC, making mirror stale
 122           MutexLocker ml(some_lock);
 123 
 124           // And here&#39;s an initializer that can result in a stale oop
 125           // all in one step.
 126           oop o = call_that_can_throw_exception(TRAPS);
 127 
 128 
 129   The solution is to keep the oop declaration BELOW the ctor or function
 130   call that might cause a GC, do another resolve to reassign the oop, or
 131   consider use of a Handle instead of an oop so there is immunity from object
 132   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 133   and thus can only support use of handles passed in.
 134 */
 135 
 136 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 137   ResourceMark rm;
 138   int line_number = -1;
 139   const char * source_file = NULL;
 140   const char * trace = &quot;explicit&quot;;
 141   InstanceKlass* caller = NULL;
 142   JavaThread* jthread = JavaThread::current();
 143   if (jthread-&gt;has_last_Java_frame()) {
 144     vframeStream vfst(jthread);
 145 
 146     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 147     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 148     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 149     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 150     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 151 
 152     Method* last_caller = NULL;
 153 
 154     while (!vfst.at_end()) {
 155       Method* m = vfst.method();
 156       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 157           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 158           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 159         break;
 160       }
 161       last_caller = m;
 162       vfst.next();
 163     }
 164     // if this is called from Class.forName0 and that is called from Class.forName,
 165     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 166     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 167     bool found_it = false;
 168     if (!vfst.at_end() &amp;&amp;
 169         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 170         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 171       vfst.next();
 172       if (!vfst.at_end() &amp;&amp;
 173           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 174           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 175         vfst.next();
 176         found_it = true;
 177       }
 178     } else if (last_caller != NULL &amp;&amp;
 179                last_caller-&gt;method_holder()-&gt;name() ==
 180                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 181                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 182       found_it = true;
 183     } else if (!vfst.at_end()) {
 184       if (vfst.method()-&gt;is_native()) {
 185         // JNI call
 186         found_it = true;
 187       }
 188     }
 189     if (found_it &amp;&amp; !vfst.at_end()) {
 190       // found the caller
 191       caller = vfst.method()-&gt;method_holder();
 192       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 193       if (line_number == -1) {
 194         // show method name if it&#39;s a native method
 195         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 196       }
 197       Symbol* s = caller-&gt;source_file_name();
 198       if (s != NULL) {
 199         source_file = s-&gt;as_C_string();
 200       }
 201     }
 202   }
 203   if (caller != NULL) {
 204     if (to_class != caller) {
 205       const char * from = caller-&gt;external_name();
 206       const char * to = to_class-&gt;external_name();
 207       // print in a single call to reduce interleaving between threads
 208       if (source_file != NULL) {
 209         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 210       } else {
 211         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 212       }
 213     }
 214   }
 215 }
 216 
 217 void trace_class_resolution(Klass* to_class) {
 218   EXCEPTION_MARK;
 219   trace_class_resolution_impl(to_class, THREAD);
 220   if (HAS_PENDING_EXCEPTION) {
 221     CLEAR_PENDING_EXCEPTION;
 222   }
 223 }
 224 
 225 // Wrapper to trace JVM functions
 226 
 227 #ifdef ASSERT
 228   Histogram* JVMHistogram;
 229   volatile int JVMHistogram_lock = 0;
 230 
 231   class JVMHistogramElement : public HistogramElement {
 232     public:
 233      JVMHistogramElement(const char* name);
 234   };
 235 
 236   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 237     _name = elementName;
 238     uintx count = 0;
 239 
 240     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 241       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 242         count +=1;
 243         if ( (WarnOnStalledSpinLock &gt; 0)
 244           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 245           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 246         }
 247       }
 248      }
 249 
 250     if(JVMHistogram == NULL)
 251       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 252 
 253     JVMHistogram-&gt;add_element(this);
 254     Atomic::dec(&amp;JVMHistogram_lock);
 255   }
 256 
 257   #define JVMCountWrapper(arg) \
 258       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 259       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 260 
 261   #define JVMWrapper(arg) JVMCountWrapper(arg);
 262 #else
 263   #define JVMWrapper(arg)
 264 #endif
 265 
 266 
 267 // Interface version /////////////////////////////////////////////////////////////////////
 268 
 269 
 270 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 271   return JVM_INTERFACE_VERSION;
 272 JVM_END
 273 
 274 
 275 // java.lang.System //////////////////////////////////////////////////////////////////////
 276 
 277 
 278 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 279   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 280   return os::javaTimeMillis();
 281 JVM_END
 282 
 283 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 284   JVMWrapper(&quot;JVM_NanoTime&quot;);
 285   return os::javaTimeNanos();
 286 JVM_END
 287 
 288 // The function below is actually exposed by jdk.internal.misc.VM and not
 289 // java.lang.System, but we choose to keep it here so that it stays next
 290 // to JVM_CurrentTimeMillis and JVM_NanoTime
 291 
 292 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 293 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 294 
 295 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 296   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 297   jlong seconds;
 298   jlong nanos;
 299 
 300   os::javaTimeSystemUTC(seconds, nanos);
 301 
 302   // We&#39;re going to verify that the result can fit in a long.
 303   // For that we need the difference in seconds between &#39;seconds&#39;
 304   // and &#39;offset_secs&#39; to be such that:
 305   //     |seconds - offset_secs| &lt; (2^63/10^9)
 306   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 307   // which makes |seconds - offset_secs| &lt; 2^33
 308   // and we will prefer +/- 2^32 as the maximum acceptable diff
 309   // as 2^32 has a more natural feel than 2^33...
 310   //
 311   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 312   // sentinel value (-1) which the caller should take as an
 313   // exception value indicating that the offset given to us is
 314   // too far from range of the current time - leading to too big
 315   // a nano adjustment. The caller is expected to recover by
 316   // computing a more accurate offset and calling this method
 317   // again. (For the record 2^32 secs is ~136 years, so that
 318   // should rarely happen)
 319   //
 320   jlong diff = seconds - offset_secs;
 321   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 322      return -1; // sentinel value: the offset is too far off the target
 323   }
 324 
 325   // return the adjustment. If you compute a time by adding
 326   // this number of nanoseconds along with the number of seconds
 327   // in the offset you should get the current UTC time.
 328   return (diff * (jlong)1000000000) + nanos;
 329 JVM_END
 330 
 331 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 332                                jobject dst, jint dst_pos, jint length))
 333   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 334   // Check if we have null pointers
 335   if (src == NULL || dst == NULL) {
 336     THROW(vmSymbols::java_lang_NullPointerException());
 337   }
 338   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 339   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 340   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 341   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 342   // Do copy
 343   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 344 JVM_END
 345 
 346 
 347 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 348   JavaValue r(T_OBJECT);
 349   // public synchronized Object put(Object key, Object value);
 350   HandleMark hm(THREAD);
 351   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 352   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 353   JavaCalls::call_virtual(&amp;r,
 354                           props,
 355                           SystemDictionary::Properties_klass(),
 356                           vmSymbols::put_name(),
 357                           vmSymbols::object_object_object_signature(),
 358                           key_str,
 359                           value_str,
 360                           THREAD);
 361 }
 362 
 363 
 364 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 365 
 366 /*
 367  * Return all of the system properties in a Java String array with alternating
 368  * names and values from the jvm SystemProperty.
 369  * Which includes some internal and all commandline -D defined properties.
 370  */
 371 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 372   JVMWrapper(&quot;JVM_GetProperties&quot;);
 373   ResourceMark rm(THREAD);
 374   HandleMark hm(THREAD);
 375   int ndx = 0;
 376   int fixedCount = 2;
 377 
 378   SystemProperty* p = Arguments::system_properties();
 379   int count = Arguments::PropertyList_count(p);
 380 
 381   // Allocate result String array
 382   InstanceKlass* ik = SystemDictionary::String_klass();
 383   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 384   objArrayHandle result_h(THREAD, r);
 385 
 386   while (p != NULL) {
 387     const char * key = p-&gt;key();
 388     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 389         const char * value = p-&gt;value();
 390         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 391         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 392         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 393         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 394         ndx++;
 395     }
 396     p = p-&gt;next();
 397   }
 398 
 399   // Convert the -XX:MaxDirectMemorySize= command line flag
 400   // to the sun.nio.MaxDirectMemorySize property.
 401   // Do this after setting user properties to prevent people
 402   // from setting the value with a -D option, as requested.
 403   // Leave empty if not supplied
 404   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 405     char as_chars[256];
 406     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 407     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 408     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 409     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 410     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 411     ndx++;
 412   }
 413 
 414   // JVM monitoring and management support
 415   // Add the sun.management.compiler property for the compiler&#39;s name
 416   {
 417 #undef CSIZE
 418 #if defined(_LP64) || defined(_WIN64)
 419   #define CSIZE &quot;64-Bit &quot;
 420 #else
 421   #define CSIZE
 422 #endif // 64bit
 423 
 424 #ifdef TIERED
 425     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 426 #else
 427 #if defined(COMPILER1)
 428     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 429 #elif defined(COMPILER2)
 430     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 431 #elif INCLUDE_JVMCI
 432     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 433 #else
 434     const char* compiler_name = &quot;&quot;;
 435 #endif // compilers
 436 #endif // TIERED
 437 
 438     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 439         (Arguments::mode() != Arguments::_int)) {
 440       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 441       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 442       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 443       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 444       ndx++;
 445     }
 446   }
 447 
 448   return (jobjectArray) JNIHandles::make_local(env, result_h());
 449 JVM_END
 450 
 451 
 452 /*
 453  * Return the temporary directory that the VM uses for the attach
 454  * and perf data files.
 455  *
 456  * It is important that this directory is well-known and the
 457  * same for all VM instances. It cannot be affected by configuration
 458  * variables such as java.io.tmpdir.
 459  */
 460 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 461   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 462   HandleMark hm(THREAD);
 463   const char* temp_dir = os::get_temp_directory();
 464   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 465   return (jstring) JNIHandles::make_local(env, h());
 466 JVM_END
 467 
 468 
 469 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 470 
 471 extern volatile jint vm_created;
 472 
 473 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 474   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 475   EventShutdown event;
 476   if (event.should_commit()) {
 477     event.set_reason(&quot;Shutdown requested from Java&quot;);
 478     event.commit();
 479   }
 480 JVM_END
 481 
 482 
 483 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 484   before_exit(thread);
 485   vm_exit(code);
 486 JVM_END
 487 
 488 
 489 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 490   JVMWrapper(&quot;JVM_GC&quot;);
 491   if (!DisableExplicitGC) {
 492     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 493   }
 494 JVM_END
 495 
 496 
 497 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 498   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 499   return Universe::heap()-&gt;millis_since_last_gc();
 500 JVM_END
 501 
 502 
 503 static inline jlong convert_size_t_to_jlong(size_t val) {
 504   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 505   NOT_LP64 (return (jlong)val;)
 506   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 507 }
 508 
 509 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 510   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 511   size_t n = Universe::heap()-&gt;capacity();
 512   return convert_size_t_to_jlong(n);
 513 JVM_END
 514 
 515 
 516 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 517   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 518   size_t n = Universe::heap()-&gt;unused();
 519   return convert_size_t_to_jlong(n);
 520 JVM_END
 521 
 522 
 523 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 524   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 525   size_t n = Universe::heap()-&gt;max_capacity();
 526   return convert_size_t_to_jlong(n);
 527 JVM_END
 528 
 529 
 530 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 531   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 532   return os::active_processor_count();
 533 JVM_END
 534 
 535 
 536 
 537 // java.lang.Throwable //////////////////////////////////////////////////////
 538 
 539 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver, jobject contScope))
 540   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 541   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 542   Handle scope(thread, JNIHandles::resolve(contScope));
 543 
 544   java_lang_Throwable::fill_in_stack_trace(exception, scope);
 545 JVM_END
 546 
 547 // java.lang.NullPointerException ///////////////////////////////////////////
 548 
 549 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 550   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 551 
 552   oop exc = JNIHandles::resolve_non_null(throwable);
 553 
 554   Method* method;
 555   int bci;
 556   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 557     return NULL;
 558   }
 559   if (method-&gt;is_native()) {
 560     return NULL;
 561   }
 562 
 563   stringStream ss;
 564   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 565   if (ok) {
 566     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);
 567     return (jstring) JNIHandles::make_local(env, result);
 568   } else {
 569     return NULL;
 570   }
 571 JVM_END
 572 
 573 // java.lang.StackTraceElement //////////////////////////////////////////////
 574 
 575 
 576 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 577   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 578   Handle exception(THREAD, JNIHandles::resolve(throwable));
 579   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 580   objArrayHandle stack_trace(THREAD, st);
 581   // Fill in the allocated stack trace
 582   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 583 JVM_END
 584 
 585 
 586 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 587   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 588   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 589   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 590   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 591 JVM_END
 592 
 593 
 594 // java.lang.StackWalker //////////////////////////////////////////////////////
 595 
 596 
 597 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 598                                      jint skip_frames, jobject contScope, jobject cont,
 599                                      jint frame_count, jint start_index, jobjectArray frames))
 600   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 601   JavaThread* jt = (JavaThread*) THREAD;
 602   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 603     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 604   }
 605 
 606   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 607   Handle contScope_h(THREAD, JNIHandles::resolve(contScope));
 608   Handle cont_h(THREAD, JNIHandles::resolve(cont));
 609   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 610   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 611   // be null.
 612   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 613   objArrayHandle frames_array_h(THREAD, fa);
 614 
 615   int limit = start_index + frame_count;
 616   if (frames_array_h-&gt;length() &lt; limit) {
 617     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 618   }
 619 
 620   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, contScope_h, cont_h,
 621                                frame_count, start_index, frames_array_h, CHECK_NULL);
 622   return JNIHandles::make_local(env, result);
 623 JVM_END
 624 
 625 
 626 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 627                                   jint frame_count, jint start_index,
 628                                   jobjectArray frames))
 629   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 630 
 631   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 632   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 633   // be null.
 634   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 635   objArrayHandle frames_array_h(THREAD, fa);
 636 
 637   int limit = start_index+frame_count;
 638   if (frames_array_h-&gt;length() &lt; limit) {
 639     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 640   }
 641 
 642   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 643   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 644                                   start_index, frames_array_h, THREAD);
 645 JVM_END
 646 
 647 JVM_ENTRY(void, JVM_SetStackWalkContinuation(JNIEnv *env, jobject stackStream, jlong anchor, jobjectArray frames, jobject cont))
 648     JVMWrapper(&quot;JVM_SetStackWalkContinuation&quot;);
 649 
 650     objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 651     objArrayHandle frames_array_h(THREAD, fa);
 652     Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 653     Handle cont_h(THREAD, JNIHandles::resolve_non_null(cont));
 654 
 655     StackWalk::setContinuation(stackStream_h, anchor, frames_array_h, cont_h, THREAD);
 656 JVM_END
 657 
 658 // java.lang.Object ///////////////////////////////////////////////
 659 
 660 
 661 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 662   JVMWrapper(&quot;JVM_IHashCode&quot;);
 663   // as implemented in the classic virtual machine; return 0 if object is NULL
 664   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 665 JVM_END
 666 
 667 
 668 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 669   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 670   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 671   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 672   if (JvmtiExport::should_post_monitor_wait()) {
 673     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 674 
 675     // The current thread already owns the monitor and it has not yet
 676     // been added to the wait queue so the current thread cannot be
 677     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 678     // event handler cannot accidentally consume an unpark() meant for
 679     // the ParkEvent associated with this ObjectMonitor.
 680   }
 681   ObjectSynchronizer::wait(obj, ms, CHECK);
 682 JVM_END
 683 
 684 
 685 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 686   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 687   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 688   ObjectSynchronizer::notify(obj, CHECK);
 689 JVM_END
 690 
 691 
 692 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 693   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 694   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 695   ObjectSynchronizer::notifyall(obj, CHECK);
 696 JVM_END
 697 
 698 
 699 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 700   JVMWrapper(&quot;JVM_Clone&quot;);
 701   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 702   Klass* klass = obj-&gt;klass();
 703   JvmtiVMObjectAllocEventCollector oam;
 704 
 705 #ifdef ASSERT
 706   // Just checking that the cloneable flag is set correct
 707   if (obj-&gt;is_array()) {
 708     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 709   } else {
 710     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 711     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 712     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 713   }
 714 #endif
 715 
 716   // Check if class of obj supports the Cloneable interface.
 717   // All arrays are considered to be cloneable (See JLS 20.1.5).
 718   // All j.l.r.Reference classes are considered non-cloneable.
 719   if (!klass-&gt;is_cloneable() ||
 720       (klass-&gt;is_instance_klass() &amp;&amp;
 721        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 722     ResourceMark rm(THREAD);
 723     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 724   }
 725 
 726   // Make shallow object copy
 727   const int size = obj-&gt;size();
 728   oop new_obj_oop = NULL;
 729   if (obj-&gt;is_array()) {
 730     const int length = ((arrayOop)obj())-&gt;length();
 731     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 732                                                    /* do_zero */ true, CHECK_NULL);
 733   } else {
 734     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 735   }
 736 
 737   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 738 
 739   Handle new_obj(THREAD, new_obj_oop);
 740   // Caution: this involves a java upcall, so the clone should be
 741   // &quot;gc-robust&quot; by this stage.
 742   if (klass-&gt;has_finalizer()) {
 743     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 744     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 745     new_obj = Handle(THREAD, new_obj_oop);
 746   }
 747 
 748   return JNIHandles::make_local(env, new_obj());
 749 JVM_END
 750 
 751 // java.lang.Continuation /////////////////////////////////////////////////////
 752 
 753 JVM_ENTRY(void, JVM_RegisterContinuationMethods(JNIEnv *env, jclass cls))
 754   CONT_RegisterNativeMethods(env, cls);
 755 JVM_END
 756 
 757 // java.io.File ///////////////////////////////////////////////////////////////
 758 
 759 JVM_LEAF(char*, JVM_NativePath(char* path))
 760   JVMWrapper(&quot;JVM_NativePath&quot;);
 761   return os::native_path(path);
 762 JVM_END
 763 
 764 
 765 // Misc. class handling ///////////////////////////////////////////////////////////
 766 
 767 
 768 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 769   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 770 
 771   // Getting the class of the caller frame.
 772   //
 773   // The call stack at this point looks something like this:
 774   //
 775   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 776   // [1] [ @CallerSensitive API.method                                   ]
 777   // [.] [ (skipped intermediate frames)                                 ]
 778   // [n] [ caller                                                        ]
 779   vframeStream vfst(thread);
 780   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 781   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 782     Method* m = vfst.method();
 783     assert(m != NULL, &quot;sanity&quot;);
 784     switch (n) {
 785     case 0:
 786       // This must only be called from Reflection.getCallerClass
 787       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 788         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 789       }
 790       // fall-through
 791     case 1:
 792       // Frame 0 and 1 must be caller sensitive.
 793       if (!m-&gt;caller_sensitive()) {
 794         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 795       }
 796       break;
 797     default:
 798       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 799         // We have reached the desired frame; return the holder class.
 800         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 801       }
 802       break;
 803     }
 804   }
 805   return NULL;
 806 JVM_END
 807 
 808 
 809 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 810   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 811   oop mirror = NULL;
 812   BasicType t = name2type(utf);
 813   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 814     mirror = Universe::java_mirror(t);
 815   }
 816   if (mirror == NULL) {
 817     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 818   } else {
 819     return (jclass) JNIHandles::make_local(env, mirror);
 820   }
 821 JVM_END
 822 
 823 
 824 // Returns a class loaded by the bootstrap class loader; or null
 825 // if not found.  ClassNotFoundException is not thrown.
 826 // FindClassFromBootLoader is exported to the launcher for windows.
 827 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 828                                               const char* name))
 829   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 830 
 831   // Java libraries should ensure that name is never null...
 832   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 833     // It&#39;s impossible to create this class;  the name cannot fit
 834     // into the constant pool.
 835     return NULL;
 836   }
 837 
 838   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 839   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 840   if (k == NULL) {
 841     return NULL;
 842   }
 843 
 844   if (log_is_enabled(Debug, class, resolve)) {
 845     trace_class_resolution(k);
 846   }
 847   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 848 JVM_END
 849 
 850 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 851 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 852                                           jboolean init, jobject loader,
 853                                           jclass caller))
 854   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 855   // Java libraries should ensure that name is never null...
 856   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 857     // It&#39;s impossible to create this class;  the name cannot fit
 858     // into the constant pool.
 859     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 860   }
 861 
 862   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 863 
 864   oop loader_oop = JNIHandles::resolve(loader);
 865   oop from_class = JNIHandles::resolve(caller);
 866   oop protection_domain = NULL;
 867   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 868   // NPE. Put it in another way, the bootstrap class loader has all permission and
 869   // thus no checkPackageAccess equivalence in the VM class loader.
 870   // The caller is also passed as NULL by the java code if there is no security
 871   // manager to avoid the performance cost of getting the calling class.
 872   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 873     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 874   }
 875 
 876   Handle h_loader(THREAD, loader_oop);
 877   Handle h_prot(THREAD, protection_domain);
 878   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 879                                                h_prot, false, THREAD);
 880 
 881   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 882     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 883   }
 884   return result;
 885 JVM_END
 886 
 887 // Currently only called from the old verifier.
 888 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 889                                          jboolean init, jclass from))
 890   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 891   if (name == NULL) {
 892     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 893   }
 894   if ((int)strlen(name) &gt; Symbol::max_length()) {
 895     // It&#39;s impossible to create this class;  the name cannot fit
 896     // into the constant pool.
 897     Exceptions::fthrow(THREAD_AND_LOCATION,
 898                        vmSymbols::java_lang_NoClassDefFoundError(),
 899                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 900                        Symbol::max_length(),
 901                        name);
 902     return 0;
 903   }
 904   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 905   oop from_class_oop = JNIHandles::resolve(from);
 906   Klass* from_class = (from_class_oop == NULL)
 907                            ? (Klass*)NULL
 908                            : java_lang_Class::as_Klass(from_class_oop);
 909   oop class_loader = NULL;
 910   oop protection_domain = NULL;
 911   if (from_class != NULL) {
 912     class_loader = from_class-&gt;class_loader();
 913     protection_domain = from_class-&gt;protection_domain();
 914   }
 915   Handle h_loader(THREAD, class_loader);
 916   Handle h_prot  (THREAD, protection_domain);
 917   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 918                                                h_prot, true, thread);
 919 
 920   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 921     // this function is generally only used for class loading during verification.
 922     ResourceMark rm;
 923     oop from_mirror = JNIHandles::resolve_non_null(from);
 924     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 925     const char * from_name = from_class-&gt;external_name();
 926 
 927     oop mirror = JNIHandles::resolve_non_null(result);
 928     Klass* to_class = java_lang_Class::as_Klass(mirror);
 929     const char * to = to_class-&gt;external_name();
 930     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 931   }
 932 
 933   return result;
 934 JVM_END
 935 
 936 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 937   if (loader.is_null()) {
 938     return;
 939   }
 940 
 941   // check whether the current caller thread holds the lock or not.
 942   // If not, increment the corresponding counter
 943   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 944       ObjectSynchronizer::owner_self) {
 945     counter-&gt;inc();
 946   }
 947 }
 948 
 949 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 950 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 951                                       jobject loader, const jbyte *buf,
 952                                       jsize len, jobject pd, const char *source,
 953                                       TRAPS) {
 954   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 955 
 956   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 957   JavaThread* jt = (JavaThread*) THREAD;
 958 
 959   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 960                              ClassLoader::perf_define_appclass_selftime(),
 961                              ClassLoader::perf_define_appclasses(),
 962                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 963                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 964                              PerfClassTraceTime::DEFINE_CLASS);
 965 
 966   if (UsePerfData) {
 967     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 968   }
 969 
 970   // Since exceptions can be thrown, class initialization can take place
 971   // if name is NULL no check for class name in .class stream has to be made.
 972   TempNewSymbol class_name = NULL;
 973   if (name != NULL) {
 974     const int str_len = (int)strlen(name);
 975     if (str_len &gt; Symbol::max_length()) {
 976       // It&#39;s impossible to create this class;  the name cannot fit
 977       // into the constant pool.
 978       Exceptions::fthrow(THREAD_AND_LOCATION,
 979                          vmSymbols::java_lang_NoClassDefFoundError(),
 980                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 981                          Symbol::max_length(),
 982                          name);
 983       return 0;
 984     }
 985     class_name = SymbolTable::new_symbol(name, str_len);
 986   }
 987 
 988   ResourceMark rm(THREAD);
 989   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 990   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 991   if (UsePerfData) {
 992     is_lock_held_by_thread(class_loader,
 993                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 994                            THREAD);
 995   }
 996   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 997   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 998                                                    class_loader,
 999                                                    protection_domain,
1000                                                    &amp;st,
1001                                                    CHECK_NULL);
1002 
1003   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
1004     trace_class_resolution(k);
1005   }
1006 
1007   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1008 }
1009 
1010 
1011 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1012   JVMWrapper(&quot;JVM_DefineClass&quot;);
1013 
1014   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1015 JVM_END
1016 
1017 
1018 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1019   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1020 
1021   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1022 JVM_END
1023 
1024 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1025   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1026   ResourceMark rm(THREAD);
1027 
1028   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1029   char* str = java_lang_String::as_utf8_string(h_name());
1030 
1031   // Sanity check, don&#39;t expect null
1032   if (str == NULL) return NULL;
1033 
1034   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1035   char* p = (char*)str;
1036   while (*p != &#39;\0&#39;) {
1037       if (*p == &#39;.&#39;) {
1038           *p = &#39;/&#39;;
1039       }
1040       p++;
1041   }
1042 
1043   const int str_len = (int)(p - str);
1044   if (str_len &gt; Symbol::max_length()) {
1045     // It&#39;s impossible to create this class;  the name cannot fit
1046     // into the constant pool.
1047     return NULL;
1048   }
1049   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1050 
1051   // Security Note:
1052   //   The Java level wrapper will perform the necessary security check allowing
1053   //   us to pass the NULL as the initiating class loader.
1054   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1055   if (UsePerfData) {
1056     is_lock_held_by_thread(h_loader,
1057                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1058                            THREAD);
1059   }
1060 
1061   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1062                                                               h_loader,
1063                                                               Handle(),
1064                                                               CHECK_NULL);
1065 #if INCLUDE_CDS
1066   if (k == NULL) {
1067     // If the class is not already loaded, try to see if it&#39;s in the shared
1068     // archive for the current classloader (h_loader).
1069     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1070   }
1071 #endif
1072   return (k == NULL) ? NULL :
1073             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1074 JVM_END
1075 
1076 // Module support //////////////////////////////////////////////////////////////////////////////
1077 
1078 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1079                                  jstring location, const char* const* packages, jsize num_packages))
1080   JVMWrapper(&quot;JVM_DefineModule&quot;);
1081   Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);
1082 JVM_END
1083 
1084 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1085   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1086   Modules::set_bootloader_unnamed_module(module, CHECK);
1087 JVM_END
1088 
1089 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))
1090   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1091   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1092 JVM_END
1093 
1094 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))
1095   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1096   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1097 JVM_END
1098 
1099 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))
1100   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1101   Modules::add_module_exports(from_module, package, NULL, CHECK);
1102 JVM_END
1103 
1104 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1105   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1106   Modules::add_reads_module(from_module, source_module, CHECK);
1107 JVM_END
1108 
1109 // Reflection support //////////////////////////////////////////////////////////////////////////////
1110 
1111 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1112   assert (cls != NULL, &quot;illegal class&quot;);
1113   JVMWrapper(&quot;JVM_InitClassName&quot;);
1114   JvmtiVMObjectAllocEventCollector oam;
1115   ResourceMark rm(THREAD);
1116   HandleMark hm(THREAD);
1117   Handle java_class(THREAD, JNIHandles::resolve(cls));
1118   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1119   return (jstring) JNIHandles::make_local(env, result);
1120 JVM_END
1121 
1122 
1123 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1124   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1125   JvmtiVMObjectAllocEventCollector oam;
1126   oop mirror = JNIHandles::resolve_non_null(cls);
1127 
1128   // Special handling for primitive objects
1129   if (java_lang_Class::is_primitive(mirror)) {
1130     // Primitive objects does not have any interfaces
1131     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1132     return (jobjectArray) JNIHandles::make_local(env, r);
1133   }
1134 
1135   Klass* klass = java_lang_Class::as_Klass(mirror);
1136   // Figure size of result array
1137   int size;
1138   if (klass-&gt;is_instance_klass()) {
1139     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1140   } else {
1141     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1142     size = 2;
1143   }
1144 
1145   // Allocate result array
1146   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1147   objArrayHandle result (THREAD, r);
1148   // Fill in result
1149   if (klass-&gt;is_instance_klass()) {
1150     // Regular instance klass, fill in all local interfaces
1151     for (int index = 0; index &lt; size; index++) {
1152       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1153       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1154     }
1155   } else {
1156     // All arrays implement java.lang.Cloneable and java.io.Serializable
1157     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1158     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1159   }
1160   return (jobjectArray) JNIHandles::make_local(env, result());
1161 JVM_END
1162 
1163 
1164 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1165   JVMWrapper(&quot;JVM_IsInterface&quot;);
1166   oop mirror = JNIHandles::resolve_non_null(cls);
1167   if (java_lang_Class::is_primitive(mirror)) {
1168     return JNI_FALSE;
1169   }
1170   Klass* k = java_lang_Class::as_Klass(mirror);
1171   jboolean result = k-&gt;is_interface();
1172   assert(!result || k-&gt;is_instance_klass(),
1173          &quot;all interfaces are instance types&quot;);
1174   // The compiler intrinsic for isInterface tests the
1175   // Klass::_access_flags bits in the same way.
1176   return result;
1177 JVM_END
1178 
1179 
1180 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1181   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1182   JvmtiVMObjectAllocEventCollector oam;
1183   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1184     // There are no signers for primitive types
1185     return NULL;
1186   }
1187 
1188   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1189 
1190   // If there are no signers set in the class, or if the class
1191   // is an array, return NULL.
1192   if (signers == NULL) return NULL;
1193 
1194   // copy of the signers array
1195   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1196   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1197   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1198     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1199   }
1200 
1201   // return the copy
1202   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1203 JVM_END
1204 
1205 
1206 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1207   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1208   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1209     // This call is ignored for primitive types and arrays.
1210     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1211     // be called with an array.  Only the bootstrap loader creates arrays.
1212     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1213     if (k-&gt;is_instance_klass()) {
1214       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1215     }
1216   }
1217 JVM_END
1218 
1219 
1220 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1221   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1222   if (JNIHandles::resolve(cls) == NULL) {
1223     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1224   }
1225 
1226   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1227     // Primitive types does not have a protection domain.
1228     return NULL;
1229   }
1230 
1231   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1232   return (jobject) JNIHandles::make_local(env, pd);
1233 JVM_END
1234 
1235 
1236 // Returns the inherited_access_control_context field of the running thread.
1237 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1238   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1239   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1240   return JNIHandles::make_local(env, result);
1241 JVM_END
1242 
1243 class RegisterArrayForGC {
1244  private:
1245   JavaThread *_thread;
1246  public:
1247   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1248     _thread = thread;
1249     _thread-&gt;register_array_for_gc(array);
1250   }
1251 
1252   ~RegisterArrayForGC() {
1253     _thread-&gt;register_array_for_gc(NULL);
1254   }
1255 };
1256 
1257 
1258 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1259   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1260   if (!UsePrivilegedStack) return NULL;
1261 
1262   ResourceMark rm(THREAD);
1263   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1264   JvmtiVMObjectAllocEventCollector oam;
1265 
1266   // count the protection domains on the execution stack. We collapse
1267   // duplicate consecutive protection domains into a single one, as
1268   // well as stopping when we hit a privileged frame.
1269 
1270   oop previous_protection_domain = NULL;
1271   Handle privileged_context(thread, NULL);
1272   bool is_privileged = false;
1273   oop protection_domain = NULL;
1274 
1275   // Iterate through Java frames
1276   vframeStream vfst(thread);
1277   for(; !vfst.at_end(); vfst.next()) {
1278     // get method of frame
1279     Method* method = vfst.method();
1280 
1281     // stop at the first privileged frame
1282     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1283       method-&gt;name() == vmSymbols::executePrivileged_name())
1284     {
1285       // this frame is privileged
1286       is_privileged = true;
1287 
1288       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1289 
1290       StackValueCollection* locals = priv-&gt;locals();
1291       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1292       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1293       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1294       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1295       privileged_context    = ctx_sv-&gt;get_obj();
1296       Handle caller         = clr_sv-&gt;get_obj();
1297 
1298       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1299       protection_domain  = caller_klass-&gt;protection_domain();
1300     } else {
1301       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1302     }
1303 
1304     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1305       local_array-&gt;push(protection_domain);
1306       previous_protection_domain = protection_domain;
1307     }
1308 
1309     if (is_privileged) break;
1310   }
1311 
1312 
1313   // either all the domains on the stack were system domains, or
1314   // we had a privileged system domain
1315   if (local_array-&gt;is_empty()) {
1316     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1317 
1318     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1319     return JNIHandles::make_local(env, result);
1320   }
1321 
1322   // the resource area must be registered in case of a gc
1323   RegisterArrayForGC ragc(thread, local_array);
1324   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1325                                                  local_array-&gt;length(), CHECK_NULL);
1326   objArrayHandle h_context(thread, context);
1327   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1328     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1329   }
1330 
1331   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1332 
1333   return JNIHandles::make_local(env, result);
1334 JVM_END
1335 
1336 
1337 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1338   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1339   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1340   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1341 JVM_END
1342 
1343 
1344 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1345   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1346   oop mirror = JNIHandles::resolve_non_null(cls);
1347   return (jboolean) java_lang_Class::is_primitive(mirror);
1348 JVM_END
1349 
1350 
1351 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1352   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1353   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1354     // Primitive type
1355     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1356   }
1357 
1358   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1359   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1360   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1361   return k-&gt;modifier_flags();
1362 JVM_END
1363 
1364 
1365 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1366 
1367 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1368   JvmtiVMObjectAllocEventCollector oam;
1369   // ofClass is a reference to a java_lang_Class object. The mirror object
1370   // of an InstanceKlass
1371 
1372   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1373       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1374     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1375     return (jobjectArray)JNIHandles::make_local(env, result);
1376   }
1377 
1378   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1379   InnerClassesIterator iter(k);
1380 
1381   if (iter.length() == 0) {
1382     // Neither an inner nor outer class
1383     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1384     return (jobjectArray)JNIHandles::make_local(env, result);
1385   }
1386 
1387   // find inner class info
1388   constantPoolHandle cp(thread, k-&gt;constants());
1389   int length = iter.length();
1390 
1391   // Allocate temp. result array
1392   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1393   objArrayHandle result (THREAD, r);
1394   int members = 0;
1395 
1396   for (; !iter.done(); iter.next()) {
1397     int ioff = iter.inner_class_info_index();
1398     int ooff = iter.outer_class_info_index();
1399 
1400     if (ioff != 0 &amp;&amp; ooff != 0) {
1401       // Check to see if the name matches the class we&#39;re looking for
1402       // before attempting to find the class.
1403       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1404         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1405         if (outer_klass == k) {
1406            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1407            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1408 
1409            // Throws an exception if outer klass has not declared k as
1410            // an inner klass
1411            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1412 
1413            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1414            members++;
1415         }
1416       }
1417     }
1418   }
1419 
1420   if (members != length) {
1421     // Return array of right length
1422     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1423     for(int i = 0; i &lt; members; i++) {
1424       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1425     }
1426     return (jobjectArray)JNIHandles::make_local(env, res);
1427   }
1428 
1429   return (jobjectArray)JNIHandles::make_local(env, result());
1430 JVM_END
1431 
1432 
1433 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1434 {
1435   // ofClass is a reference to a java_lang_Class object.
1436   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1437       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1438     return NULL;
1439   }
1440 
1441   bool inner_is_member = false;
1442   Klass* outer_klass
1443     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1444                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1445   if (outer_klass == NULL)  return NULL;  // already a top-level class
1446   if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
1447   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1448 }
1449 JVM_END
1450 
1451 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1452 {
1453   oop mirror = JNIHandles::resolve_non_null(cls);
1454   if (java_lang_Class::is_primitive(mirror) ||
1455       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1456     return NULL;
1457   }
1458   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1459   int ooff = 0, noff = 0;
1460   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1461     if (noff != 0) {
1462       constantPoolHandle i_cp(thread, k-&gt;constants());
1463       Symbol* name = i_cp-&gt;symbol_at(noff);
1464       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1465       return (jstring) JNIHandles::make_local(env, str());
1466     }
1467   }
1468   return NULL;
1469 }
1470 JVM_END
1471 
1472 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1473   assert (cls != NULL, &quot;illegal class&quot;);
1474   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1475   JvmtiVMObjectAllocEventCollector oam;
1476   ResourceMark rm(THREAD);
1477   // Return null for arrays and primatives
1478   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1479     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1480     if (k-&gt;is_instance_klass()) {
1481       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1482       if (sym == NULL) return NULL;
1483       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1484       return (jstring) JNIHandles::make_local(env, str());
1485     }
1486   }
1487   return NULL;
1488 JVM_END
1489 
1490 
1491 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1492   assert (cls != NULL, &quot;illegal class&quot;);
1493   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1494 
1495   // Return null for arrays and primitives
1496   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1497     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1498     if (k-&gt;is_instance_klass()) {
1499       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1500       return (jbyteArray) JNIHandles::make_local(env, a);
1501     }
1502   }
1503   return NULL;
1504 JVM_END
1505 
1506 
1507 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1508   // some of this code was adapted from from jni_FromReflectedField
1509 
1510   oop reflected = JNIHandles::resolve_non_null(field);
1511   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1512   Klass* k    = java_lang_Class::as_Klass(mirror);
1513   int slot      = java_lang_reflect_Field::slot(reflected);
1514   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1515 
1516   InstanceKlass* ik = InstanceKlass::cast(k);
1517   intptr_t offset = ik-&gt;field_offset(slot);
1518 
1519   if (modifiers &amp; JVM_ACC_STATIC) {
1520     // for static fields we only look in the current class
1521     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1522       assert(false, &quot;cannot find static field&quot;);
1523       return false;
1524     }
1525   } else {
1526     // for instance fields we start with the current class and work
1527     // our way up through the superclass chain
1528     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1529       assert(false, &quot;cannot find instance field&quot;);
1530       return false;
1531     }
1532   }
1533   return true;
1534 }
1535 
1536 static Method* jvm_get_method_common(jobject method) {
1537   // some of this code was adapted from from jni_FromReflectedMethod
1538 
1539   oop reflected = JNIHandles::resolve_non_null(method);
1540   oop mirror    = NULL;
1541   int slot      = 0;
1542 
1543   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1544     mirror = java_lang_reflect_Constructor::clazz(reflected);
1545     slot   = java_lang_reflect_Constructor::slot(reflected);
1546   } else {
1547     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1548            &quot;wrong type&quot;);
1549     mirror = java_lang_reflect_Method::clazz(reflected);
1550     slot   = java_lang_reflect_Method::slot(reflected);
1551   }
1552   Klass* k = java_lang_Class::as_Klass(mirror);
1553 
1554   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1555   assert(m != NULL, &quot;cannot find method&quot;);
1556   return m;  // caller has to deal with NULL in product mode
1557 }
1558 
1559 /* Type use annotations support (JDK 1.8) */
1560 
1561 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1562   assert (cls != NULL, &quot;illegal class&quot;);
1563   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1564   ResourceMark rm(THREAD);
1565   // Return null for arrays and primitives
1566   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1567     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1568     if (k-&gt;is_instance_klass()) {
1569       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1570       if (type_annotations != NULL) {
1571         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1572         return (jbyteArray) JNIHandles::make_local(env, a);
1573       }
1574     }
1575   }
1576   return NULL;
1577 JVM_END
1578 
1579 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1580   assert (method != NULL, &quot;illegal method&quot;);
1581   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1582 
1583   // method is a handle to a java.lang.reflect.Method object
1584   Method* m = jvm_get_method_common(method);
1585   if (m == NULL) {
1586     return NULL;
1587   }
1588 
1589   AnnotationArray* type_annotations = m-&gt;type_annotations();
1590   if (type_annotations != NULL) {
1591     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1592     return (jbyteArray) JNIHandles::make_local(env, a);
1593   }
1594 
1595   return NULL;
1596 JVM_END
1597 
1598 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1599   assert (field != NULL, &quot;illegal field&quot;);
1600   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1601 
1602   fieldDescriptor fd;
1603   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1604   if (!gotFd) {
1605     return NULL;
1606   }
1607 
1608   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1609 JVM_END
1610 
1611 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1612   if (!cp-&gt;is_within_bounds(index)) {
1613     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1614   }
1615 }
1616 
1617 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1618 {
1619   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1620   // method is a handle to a java.lang.reflect.Method object
1621   Method* method_ptr = jvm_get_method_common(method);
1622   methodHandle mh (THREAD, method_ptr);
1623   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1624   const int num_params = mh-&gt;method_parameters_length();
1625 
1626   if (num_params &lt; 0) {
1627     // A -1 return value from method_parameters_length means there is no
1628     // parameter data.  Return null to indicate this to the reflection
1629     // API.
1630     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1631     return (jobjectArray)NULL;
1632   } else {
1633     // Otherwise, we return something up to reflection, even if it is
1634     // a zero-length array.  Why?  Because in some cases this can
1635     // trigger a MalformedParametersException.
1636 
1637     // make sure all the symbols are properly formatted
1638     for (int i = 0; i &lt; num_params; i++) {
1639       MethodParametersElement* params = mh-&gt;method_parameters_start();
1640       int index = params[i].name_cp_index;
1641       constantPoolHandle cp(THREAD, mh-&gt;constants());
1642       bounds_check(cp, index, CHECK_NULL);
1643 
1644       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1645         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1646                     &quot;Wrong type at constant pool index&quot;);
1647       }
1648 
1649     }
1650 
1651     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1652     objArrayHandle result (THREAD, result_oop);
1653 
1654     for (int i = 0; i &lt; num_params; i++) {
1655       MethodParametersElement* params = mh-&gt;method_parameters_start();
1656       // For a 0 index, give a NULL symbol
1657       Symbol* sym = 0 != params[i].name_cp_index ?
1658         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1659       int flags = params[i].flags;
1660       oop param = Reflection::new_parameter(reflected_method, i, sym,
1661                                             flags, CHECK_NULL);
1662       result-&gt;obj_at_put(i, param);
1663     }
1664     return (jobjectArray)JNIHandles::make_local(env, result());
1665   }
1666 }
1667 JVM_END
1668 
1669 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1670 
1671 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1672 {
1673   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1674   JvmtiVMObjectAllocEventCollector oam;
1675 
1676   // Exclude primitive types and array types
1677   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1678       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1679     // Return empty array
1680     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1681     return (jobjectArray) JNIHandles::make_local(env, res);
1682   }
1683 
1684   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1685   constantPoolHandle cp(THREAD, k-&gt;constants());
1686 
1687   // Ensure class is linked
1688   k-&gt;link_class(CHECK_NULL);
1689 
1690   // Allocate result
1691   int num_fields;
1692 
1693   if (publicOnly) {
1694     num_fields = 0;
1695     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1696       if (fs.access_flags().is_public()) ++num_fields;
1697     }
1698   } else {
1699     num_fields = k-&gt;java_fields_count();
1700   }
1701 
1702   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1703   objArrayHandle result (THREAD, r);
1704 
1705   int out_idx = 0;
1706   fieldDescriptor fd;
1707   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1708     if (!publicOnly || fs.access_flags().is_public()) {
1709       fd.reinitialize(k, fs.index());
1710       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1711       result-&gt;obj_at_put(out_idx, field);
1712       ++out_idx;
1713     }
1714   }
1715   assert(out_idx == num_fields, &quot;just checking&quot;);
1716   return (jobjectArray) JNIHandles::make_local(env, result());
1717 }
1718 JVM_END
1719 
1720 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1721 {
1722   JVMWrapper(&quot;JVM_IsRecord&quot;);
1723   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1724   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1725     InstanceKlass* ik = InstanceKlass::cast(k);
1726     return ik-&gt;is_record();
1727   } else {
1728     return false;
1729   }
1730 }
1731 JVM_END
1732 
1733 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1734 {
1735   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1736   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1737   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1738   InstanceKlass* ik = InstanceKlass::cast(c);
1739 
1740   if (ik-&gt;is_record()) {
1741     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1742     assert(components != NULL, &quot;components should not be NULL&quot;);
1743     {
1744       JvmtiVMObjectAllocEventCollector oam;
1745       constantPoolHandle cp(THREAD, ik-&gt;constants());
1746       int length = components-&gt;length();
1747       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1748       objArrayOop record_components =
1749         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1750       objArrayHandle components_h (THREAD, record_components);
1751 
1752       for (int x = 0; x &lt; length; x++) {
1753         RecordComponent* component = components-&gt;at(x);
1754         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1755         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1756         components_h-&gt;obj_at_put(x, component_oop);
1757       }
1758       return (jobjectArray)JNIHandles::make_local(components_h());
1759     }
1760   }
1761 
1762   // Return empty array if ofClass is not a record.
1763   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1764   return (jobjectArray)JNIHandles::make_local(env, result);
1765 }
1766 JVM_END
1767 
1768 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1769   if (want_constructor) {
1770     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1771   } else {
1772     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1773   }
1774 }
1775 
1776 static jobjectArray get_class_declared_methods_helper(
1777                                   JNIEnv *env,
1778                                   jclass ofClass, jboolean publicOnly,
1779                                   bool want_constructor,
1780                                   Klass* klass, TRAPS) {
1781 
1782   JvmtiVMObjectAllocEventCollector oam;
1783 
1784   // Exclude primitive types and array types
1785   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1786       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1787     // Return empty array
1788     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1789     return (jobjectArray) JNIHandles::make_local(env, res);
1790   }
1791 
1792   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1793 
1794   // Ensure class is linked
1795   k-&gt;link_class(CHECK_NULL);
1796 
1797   Array&lt;Method*&gt;* methods = k-&gt;methods();
1798   int methods_length = methods-&gt;length();
1799 
1800   // Save original method_idnum in case of redefinition, which can change
1801   // the idnum of obsolete methods.  The new method will have the same idnum
1802   // but if we refresh the methods array, the counts will be wrong.
1803   ResourceMark rm(THREAD);
1804   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1805   int num_methods = 0;
1806 
1807   for (int i = 0; i &lt; methods_length; i++) {
1808     methodHandle method(THREAD, methods-&gt;at(i));
1809     if (select_method(method, want_constructor)) {
1810       if (!publicOnly || method-&gt;is_public()) {
1811         idnums-&gt;push(method-&gt;method_idnum());
1812         ++num_methods;
1813       }
1814     }
1815   }
1816 
1817   // Allocate result
1818   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1819   objArrayHandle result (THREAD, r);
1820 
1821   // Now just put the methods that we selected above, but go by their idnum
1822   // in case of redefinition.  The methods can be redefined at any safepoint,
1823   // so above when allocating the oop array and below when creating reflect
1824   // objects.
1825   for (int i = 0; i &lt; num_methods; i++) {
1826     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1827     if (method.is_null()) {
1828       // Method may have been deleted and seems this API can handle null
1829       // Otherwise should probably put a method that throws NSME
1830       result-&gt;obj_at_put(i, NULL);
1831     } else {
1832       oop m;
1833       if (want_constructor) {
1834         m = Reflection::new_constructor(method, CHECK_NULL);
1835       } else {
1836         m = Reflection::new_method(method, false, CHECK_NULL);
1837       }
1838       result-&gt;obj_at_put(i, m);
1839     }
1840   }
1841 
1842   return (jobjectArray) JNIHandles::make_local(env, result());
1843 }
1844 
1845 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1846 {
1847   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1848   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1849                                            /*want_constructor*/ false,
1850                                            SystemDictionary::reflect_Method_klass(), THREAD);
1851 }
1852 JVM_END
1853 
1854 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1855 {
1856   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1857   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1858                                            /*want_constructor*/ true,
1859                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1860 }
1861 JVM_END
1862 
1863 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1864 {
1865   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
1866   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1867     // Primitive type
1868     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1869   }
1870 
1871   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1872   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1873 }
1874 JVM_END
1875 
1876 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
1877 {
1878   JVMWrapper(&quot;JVM_AreNestMates&quot;);
1879   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1880   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1881   InstanceKlass* ck = InstanceKlass::cast(c);
1882   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
1883   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
1884   InstanceKlass* mk = InstanceKlass::cast(m);
1885   return ck-&gt;has_nestmate_access_to(mk, THREAD);
1886 }
1887 JVM_END
1888 
1889 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
1890 {
1891   // current is not a primitive or array class
1892   JVMWrapper(&quot;JVM_GetNestHost&quot;);
1893   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1894   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1895   InstanceKlass* ck = InstanceKlass::cast(c);
1896   // Don&#39;t post exceptions if validation fails
1897   InstanceKlass* host = ck-&gt;nest_host(NULL, THREAD);
1898   return (jclass) (host == NULL ? NULL :
1899                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
1900 }
1901 JVM_END
1902 
1903 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
1904 {
1905   // current is not a primitive or array class
1906   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
1907   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1908   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1909   InstanceKlass* ck = InstanceKlass::cast(c);
1910   // Get the nest host for this nest - throw ICCE if validation fails
1911   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
1912   InstanceKlass* host = ck-&gt;nest_host(icce, CHECK_NULL);
1913 
1914   {
1915     JvmtiVMObjectAllocEventCollector oam;
1916     Array&lt;u2&gt;* members = host-&gt;nest_members();
1917     int length = members == NULL ? 0 : members-&gt;length();
1918     // nest host is first in the array so make it one bigger
1919     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
1920                                              length + 1, CHECK_NULL);
1921     objArrayHandle result (THREAD, r);
1922     result-&gt;obj_at_put(0, host-&gt;java_mirror());
1923     if (length != 0) {
1924       int i;
1925       for (i = 0; i &lt; length; i++) {
1926          int cp_index = members-&gt;at(i);
1927          Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, CHECK_NULL);
1928          if (k-&gt;is_instance_klass()) {
1929            InstanceKlass* nest_host_k =
1930              InstanceKlass::cast(k)-&gt;nest_host(icce, CHECK_NULL);
1931            if (nest_host_k == host) {
1932              result-&gt;obj_at_put(i+1, k-&gt;java_mirror());
1933            }
1934            else {
1935              // k&#39;s nest host is legal but it isn&#39;t our host so
1936              // throw ICCE
1937              ResourceMark rm(THREAD);
1938              Exceptions::fthrow(THREAD_AND_LOCATION,
1939                                 icce,
1940                                 &quot;Nest member %s in %s declares a different nest host of %s&quot;,
1941                                 k-&gt;external_name(),
1942                                 host-&gt;external_name(),
1943                                 nest_host_k-&gt;external_name()
1944                            );
1945              return NULL;
1946            }
1947          }
1948          else {
1949            // we have a bad nest member entry - throw ICCE
1950            ResourceMark rm(THREAD);
1951            Exceptions::fthrow(THREAD_AND_LOCATION,
1952                               icce,
1953                               &quot;Class %s can not be a nest member of %s&quot;,
1954                               k-&gt;external_name(),
1955                               host-&gt;external_name()
1956                               );
1957            return NULL;
1958          }
1959       }
1960     }
1961     else {
1962       assert(host == ck, &quot;must be singleton nest&quot;);
1963     }
1964     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1965   }
1966 }
1967 JVM_END
1968 
1969 // Constant pool access //////////////////////////////////////////////////////////
1970 
1971 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
1972 {
1973   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
1974   JvmtiVMObjectAllocEventCollector oam;
1975 
1976   // Return null for primitives and arrays
1977   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1978     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1979     if (k-&gt;is_instance_klass()) {
1980       InstanceKlass* k_h = InstanceKlass::cast(k);
1981       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
1982       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
1983       return JNIHandles::make_local(jcp());
1984     }
1985   }
1986   return NULL;
1987 }
1988 JVM_END
1989 
1990 
1991 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
1992 {
1993   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
1994   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1995   return cp-&gt;length();
1996 }
1997 JVM_END
1998 
1999 
2000 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2001 {
2002   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2003   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2004   bounds_check(cp, index, CHECK_NULL);
2005   constantTag tag = cp-&gt;tag_at(index);
2006   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2007     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2008   }
2009   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2010   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2011 }
2012 JVM_END
2013 
2014 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2015 {
2016   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2017   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2018   bounds_check(cp, index, CHECK_NULL);
2019   constantTag tag = cp-&gt;tag_at(index);
2020   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2021     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2022   }
2023   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2024   if (k == NULL) return NULL;
2025   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2026 }
2027 JVM_END
2028 
2029 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2030   constantTag tag = cp-&gt;tag_at(index);
2031   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2032     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2033   }
2034   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2035   Klass* k_o;
2036   if (force_resolution) {
2037     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2038   } else {
2039     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2040     if (k_o == NULL) return NULL;
2041   }
2042   InstanceKlass* k = InstanceKlass::cast(k_o);
2043   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2044   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2045   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2046   if (m.is_null()) {
2047     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2048   }
2049   oop method;
2050   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2051     method = Reflection::new_method(m, true, CHECK_NULL);
2052   } else {
2053     method = Reflection::new_constructor(m, CHECK_NULL);
2054   }
2055   return JNIHandles::make_local(method);
2056 }
2057 
2058 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2059 {
2060   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2061   JvmtiVMObjectAllocEventCollector oam;
2062   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2063   bounds_check(cp, index, CHECK_NULL);
2064   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2065   return res;
2066 }
2067 JVM_END
2068 
2069 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2070 {
2071   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2072   JvmtiVMObjectAllocEventCollector oam;
2073   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2074   bounds_check(cp, index, CHECK_NULL);
2075   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2076   return res;
2077 }
2078 JVM_END
2079 
2080 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2081   constantTag tag = cp-&gt;tag_at(index);
2082   if (!tag.is_field()) {
2083     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2084   }
2085   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2086   Klass* k_o;
2087   if (force_resolution) {
2088     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2089   } else {
2090     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2091     if (k_o == NULL) return NULL;
2092   }
2093   InstanceKlass* k = InstanceKlass::cast(k_o);
2094   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2095   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2096   fieldDescriptor fd;
2097   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2098   if (target_klass == NULL) {
2099     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2100   }
2101   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2102   return JNIHandles::make_local(field);
2103 }
2104 
2105 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2106 {
2107   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2108   JvmtiVMObjectAllocEventCollector oam;
2109   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2110   bounds_check(cp, index, CHECK_NULL);
2111   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2112   return res;
2113 }
2114 JVM_END
2115 
2116 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2117 {
2118   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2119   JvmtiVMObjectAllocEventCollector oam;
2120   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2121   bounds_check(cp, index, CHECK_NULL);
2122   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2123   return res;
2124 }
2125 JVM_END
2126 
2127 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2128 {
2129   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2130   JvmtiVMObjectAllocEventCollector oam;
2131   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2132   bounds_check(cp, index, CHECK_NULL);
2133   constantTag tag = cp-&gt;tag_at(index);
2134   if (!tag.is_field_or_method()) {
2135     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2136   }
2137   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2138   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2139   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2140   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2141   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2142   objArrayHandle dest(THREAD, dest_o);
2143   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2144   dest-&gt;obj_at_put(0, str());
2145   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2146   dest-&gt;obj_at_put(1, str());
2147   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2148   dest-&gt;obj_at_put(2, str());
2149   return (jobjectArray) JNIHandles::make_local(dest());
2150 }
2151 JVM_END
2152 
2153 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2154 {
2155   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2156   JvmtiVMObjectAllocEventCollector oam;
2157   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2158   bounds_check(cp, index, CHECK_0);
2159   constantTag tag = cp-&gt;tag_at(index);
2160   if (!tag.is_field_or_method()) {
2161     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2162   }
2163   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2164 }
2165 JVM_END
2166 
2167 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2168 {
2169   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2170   JvmtiVMObjectAllocEventCollector oam;
2171   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2172   bounds_check(cp, index, CHECK_0);
2173   constantTag tag = cp-&gt;tag_at(index);
2174   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2175     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2176   }
2177   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2178 }
2179 JVM_END
2180 
2181 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2182 {
2183   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2184   JvmtiVMObjectAllocEventCollector oam;
2185   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2186   bounds_check(cp, index, CHECK_NULL);
2187   constantTag tag = cp-&gt;tag_at(index);
2188   if (!tag.is_name_and_type()) {
2189     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2190   }
2191   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2192   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2193   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2194   objArrayHandle dest(THREAD, dest_o);
2195   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2196   dest-&gt;obj_at_put(0, str());
2197   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2198   dest-&gt;obj_at_put(1, str());
2199   return (jobjectArray) JNIHandles::make_local(dest());
2200 }
2201 JVM_END
2202 
2203 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2204 {
2205   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2206   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2207   bounds_check(cp, index, CHECK_0);
2208   constantTag tag = cp-&gt;tag_at(index);
2209   if (!tag.is_int()) {
2210     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2211   }
2212   return cp-&gt;int_at(index);
2213 }
2214 JVM_END
2215 
2216 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2217 {
2218   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2219   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2220   bounds_check(cp, index, CHECK_(0L));
2221   constantTag tag = cp-&gt;tag_at(index);
2222   if (!tag.is_long()) {
2223     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2224   }
2225   return cp-&gt;long_at(index);
2226 }
2227 JVM_END
2228 
2229 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2230 {
2231   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2232   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2233   bounds_check(cp, index, CHECK_(0.0f));
2234   constantTag tag = cp-&gt;tag_at(index);
2235   if (!tag.is_float()) {
2236     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2237   }
2238   return cp-&gt;float_at(index);
2239 }
2240 JVM_END
2241 
2242 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2243 {
2244   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2245   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2246   bounds_check(cp, index, CHECK_(0.0));
2247   constantTag tag = cp-&gt;tag_at(index);
2248   if (!tag.is_double()) {
2249     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2250   }
2251   return cp-&gt;double_at(index);
2252 }
2253 JVM_END
2254 
2255 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2256 {
2257   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2258   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2259   bounds_check(cp, index, CHECK_NULL);
2260   constantTag tag = cp-&gt;tag_at(index);
2261   if (!tag.is_string()) {
2262     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2263   }
2264   oop str = cp-&gt;string_at(index, CHECK_NULL);
2265   return (jstring) JNIHandles::make_local(str);
2266 }
2267 JVM_END
2268 
2269 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2270 {
2271   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2272   JvmtiVMObjectAllocEventCollector oam;
2273   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2274   bounds_check(cp, index, CHECK_NULL);
2275   constantTag tag = cp-&gt;tag_at(index);
2276   if (!tag.is_symbol()) {
2277     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2278   }
2279   Symbol* sym = cp-&gt;symbol_at(index);
2280   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2281   return (jstring) JNIHandles::make_local(str());
2282 }
2283 JVM_END
2284 
2285 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2286 {
2287   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2288   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2289   bounds_check(cp, index, CHECK_0);
2290   constantTag tag = cp-&gt;tag_at(index);
2291   jbyte result = tag.value();
2292   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2293   // they are changed to the corresponding tags from the JVM spec, so that java code in
2294   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2295   if (tag.is_klass_or_reference()) {
2296       result = JVM_CONSTANT_Class;
2297   } else if (tag.is_string_index()) {
2298       result = JVM_CONSTANT_String;
2299   } else if (tag.is_method_type_in_error()) {
2300       result = JVM_CONSTANT_MethodType;
2301   } else if (tag.is_method_handle_in_error()) {
2302       result = JVM_CONSTANT_MethodHandle;
2303   } else if (tag.is_dynamic_constant_in_error()) {
2304       result = JVM_CONSTANT_Dynamic;
2305   }
2306   return result;
2307 }
2308 JVM_END
2309 
2310 // Assertion support. //////////////////////////////////////////////////////////
2311 
2312 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2313   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2314   assert(cls != NULL, &quot;bad class&quot;);
2315 
2316   oop r = JNIHandles::resolve(cls);
2317   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2318   if (java_lang_Class::is_primitive(r)) return false;
2319 
2320   Klass* k = java_lang_Class::as_Klass(r);
2321   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2322   if (!k-&gt;is_instance_klass()) return false;
2323 
2324   ResourceMark rm(THREAD);
2325   const char* name = k-&gt;name()-&gt;as_C_string();
2326   bool system_class = k-&gt;class_loader() == NULL;
2327   return JavaAssertions::enabled(name, system_class);
2328 
2329 JVM_END
2330 
2331 
2332 // Return a new AssertionStatusDirectives object with the fields filled in with
2333 // command-line assertion arguments (i.e., -ea, -da).
2334 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2335   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2336   JvmtiVMObjectAllocEventCollector oam;
2337   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2338   return JNIHandles::make_local(env, asd);
2339 JVM_END
2340 
2341 // Verification ////////////////////////////////////////////////////////////////////////////////
2342 
2343 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2344 
2345 // RedefineClasses support: bug 6214132 caused verification to fail.
2346 // All functions from this section should call the jvmtiThreadSate function:
2347 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2348 // The function returns a Klass* of the _scratch_class if the verifier
2349 // was invoked in the middle of the class redefinition.
2350 // Otherwise it returns its argument value which is the _the_class Klass*.
2351 // Please, refer to the description in the jvmtiThreadSate.hpp.
2352 
2353 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2354   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2355   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2356   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2357   return k-&gt;name()-&gt;as_utf8();
2358 JVM_END
2359 
2360 
2361 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2362   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2363   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2364   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2365   // types will have length zero if this is not an InstanceKlass
2366   // (length is determined by call to JVM_GetClassCPEntriesCount)
2367   if (k-&gt;is_instance_klass()) {
2368     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2369     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2370       constantTag tag = cp-&gt;tag_at(index);
2371       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2372     }
2373   }
2374 JVM_END
2375 
2376 
2377 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2378   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2379   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2380   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2381   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2382 JVM_END
2383 
2384 
2385 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2386   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2387   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2388   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2389   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2390 JVM_END
2391 
2392 
2393 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2394   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2395   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2396   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2397   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2398 JVM_END
2399 
2400 
2401 // The following methods, used for the verifier, are never called with
2402 // array klasses, so a direct cast to InstanceKlass is safe.
2403 // Typically, these methods are called in a loop with bounds determined
2404 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2405 // zero for arrays.
2406 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2407   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2408   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2409   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2410   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2411   int length = method-&gt;checked_exceptions_length();
2412   if (length &gt; 0) {
2413     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2414     for (int i = 0; i &lt; length; i++) {
2415       exceptions[i] = table[i].class_cp_index;
2416     }
2417   }
2418 JVM_END
2419 
2420 
2421 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2422   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2423   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2424   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2425   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2426   return method-&gt;checked_exceptions_length();
2427 JVM_END
2428 
2429 
2430 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2431   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2432   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2433   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2434   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2435   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2436 JVM_END
2437 
2438 
2439 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2440   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2441   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2442   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2443   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2444   return method-&gt;code_size();
2445 JVM_END
2446 
2447 
2448 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2449   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2450   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2451   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2452   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2453   ExceptionTable extable(method);
2454   entry-&gt;start_pc   = extable.start_pc(entry_index);
2455   entry-&gt;end_pc     = extable.end_pc(entry_index);
2456   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2457   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2458 JVM_END
2459 
2460 
2461 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2462   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2463   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2464   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2465   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2466   return method-&gt;exception_table_length();
2467 JVM_END
2468 
2469 
2470 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2471   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2472   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2473   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2474   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2475   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2476 JVM_END
2477 
2478 
2479 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2480   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2481   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2482   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2483   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2484 JVM_END
2485 
2486 
2487 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2488   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2489   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2490   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2491   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2492   return method-&gt;max_locals();
2493 JVM_END
2494 
2495 
2496 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2497   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2498   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2499   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2500   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2501   return method-&gt;size_of_parameters();
2502 JVM_END
2503 
2504 
2505 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2506   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2507   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2508   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2509   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2510   return method-&gt;verifier_max_stack();
2511 JVM_END
2512 
2513 
2514 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2515   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2516   ResourceMark rm(THREAD);
2517   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2518   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2519   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2520   return method-&gt;name() == vmSymbols::object_initializer_name();
2521 JVM_END
2522 
2523 
2524 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2525   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2526   ResourceMark rm(THREAD);
2527   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2528   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2529   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2530   return method-&gt;is_overpass();
2531 JVM_END
2532 
2533 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2534   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2535   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2536   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2537   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2538   return method-&gt;name()-&gt;as_utf8();
2539 JVM_END
2540 
2541 
2542 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2543   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2544   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2545   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2546   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2547   return method-&gt;signature()-&gt;as_utf8();
2548 JVM_END
2549 
2550 /**
2551  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2552  * read entries in the constant pool.  Since the old verifier always
2553  * works on a copy of the code, it will not see any rewriting that
2554  * may possibly occur in the middle of verification.  So it is important
2555  * that nothing it calls tries to use the cpCache instead of the raw
2556  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2557  */
2558 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2559   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2560   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2561   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2562   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2563   switch (cp-&gt;tag_at(cp_index).value()) {
2564     case JVM_CONSTANT_Fieldref:
2565       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2566     default:
2567       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2568   }
2569   ShouldNotReachHere();
2570   return NULL;
2571 JVM_END
2572 
2573 
2574 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2575   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2576   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2577   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2578   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2579   switch (cp-&gt;tag_at(cp_index).value()) {
2580     case JVM_CONSTANT_InterfaceMethodref:
2581     case JVM_CONSTANT_Methodref:
2582       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2583     default:
2584       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2585   }
2586   ShouldNotReachHere();
2587   return NULL;
2588 JVM_END
2589 
2590 
2591 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2592   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2593   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2594   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2595   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2596   switch (cp-&gt;tag_at(cp_index).value()) {
2597     case JVM_CONSTANT_InterfaceMethodref:
2598     case JVM_CONSTANT_Methodref:
2599       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2600     default:
2601       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2602   }
2603   ShouldNotReachHere();
2604   return NULL;
2605 JVM_END
2606 
2607 
2608 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2609   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2610   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2611   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2612   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2613   switch (cp-&gt;tag_at(cp_index).value()) {
2614     case JVM_CONSTANT_Fieldref:
2615       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2616     default:
2617       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2618   }
2619   ShouldNotReachHere();
2620   return NULL;
2621 JVM_END
2622 
2623 
2624 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2625   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2626   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2627   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2628   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2629   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2630   return classname-&gt;as_utf8();
2631 JVM_END
2632 
2633 
2634 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2635   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2636   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2637   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2638   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2639   switch (cp-&gt;tag_at(cp_index).value()) {
2640     case JVM_CONSTANT_Fieldref: {
2641       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2642       Symbol* classname = cp-&gt;klass_name_at(class_index);
2643       return classname-&gt;as_utf8();
2644     }
2645     default:
2646       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2647   }
2648   ShouldNotReachHere();
2649   return NULL;
2650 JVM_END
2651 
2652 
2653 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2654   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2655   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2656   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2657   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2658   switch (cp-&gt;tag_at(cp_index).value()) {
2659     case JVM_CONSTANT_Methodref:
2660     case JVM_CONSTANT_InterfaceMethodref: {
2661       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2662       Symbol* classname = cp-&gt;klass_name_at(class_index);
2663       return classname-&gt;as_utf8();
2664     }
2665     default:
2666       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2667   }
2668   ShouldNotReachHere();
2669   return NULL;
2670 JVM_END
2671 
2672 
2673 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2674   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2675   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2676   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2677   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2678   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2679   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2680   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2681   switch (cp-&gt;tag_at(cp_index).value()) {
2682     case JVM_CONSTANT_Fieldref: {
2683       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2684       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2685       InstanceKlass* ik = InstanceKlass::cast(k_called);
2686       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2687         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2688           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2689         }
2690       }
2691       return -1;
2692     }
2693     default:
2694       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2695   }
2696   ShouldNotReachHere();
2697   return 0;
2698 JVM_END
2699 
2700 
2701 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2702   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2703   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2704   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2705   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2706   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2707   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2708   switch (cp-&gt;tag_at(cp_index).value()) {
2709     case JVM_CONSTANT_Methodref:
2710     case JVM_CONSTANT_InterfaceMethodref: {
2711       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2712       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2713       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2714       int methods_count = methods-&gt;length();
2715       for (int i = 0; i &lt; methods_count; i++) {
2716         Method* method = methods-&gt;at(i);
2717         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2718             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2719         }
2720       }
2721       return -1;
2722     }
2723     default:
2724       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2725   }
2726   ShouldNotReachHere();
2727   return 0;
2728 JVM_END
2729 
2730 
2731 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2732 
2733 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2734   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2735 JVM_END
2736 
2737 
2738 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2739   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2740   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2741   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2742   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2743   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2744   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2745 JVM_END
2746 
2747 // Printing support //////////////////////////////////////////////////
2748 extern &quot;C&quot; {
2749 
2750 ATTRIBUTE_PRINTF(3, 0)
2751 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2752   // Reject count values that are negative signed values converted to
2753   // unsigned; see bug 4399518, 4417214
2754   if ((intptr_t)count &lt;= 0) return -1;
2755 
2756   int result = os::vsnprintf(str, count, fmt, args);
2757   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2758     result = -1;
2759   }
2760 
2761   return result;
2762 }
2763 
2764 ATTRIBUTE_PRINTF(3, 4)
2765 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2766   va_list args;
2767   int len;
2768   va_start(args, fmt);
2769   len = jio_vsnprintf(str, count, fmt, args);
2770   va_end(args);
2771   return len;
2772 }
2773 
2774 ATTRIBUTE_PRINTF(2, 3)
2775 int jio_fprintf(FILE* f, const char *fmt, ...) {
2776   int len;
2777   va_list args;
2778   va_start(args, fmt);
2779   len = jio_vfprintf(f, fmt, args);
2780   va_end(args);
2781   return len;
2782 }
2783 
2784 ATTRIBUTE_PRINTF(2, 0)
2785 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2786   if (Arguments::vfprintf_hook() != NULL) {
2787      return Arguments::vfprintf_hook()(f, fmt, args);
2788   } else {
2789     return vfprintf(f, fmt, args);
2790   }
2791 }
2792 
2793 ATTRIBUTE_PRINTF(1, 2)
2794 JNIEXPORT int jio_printf(const char *fmt, ...) {
2795   int len;
2796   va_list args;
2797   va_start(args, fmt);
2798   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2799   va_end(args);
2800   return len;
2801 }
2802 
2803 // HotSpot specific jio method
2804 void jio_print(const char* s, size_t len) {
2805   // Try to make this function as atomic as possible.
2806   if (Arguments::vfprintf_hook() != NULL) {
2807     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2808   } else {
2809     // Make an unused local variable to avoid warning from gcc 4.x compiler.
2810     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2811   }
2812 }
2813 
2814 } // Extern C
2815 
2816 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2817 
2818 // In most of the JVM thread support functions we need to access the
2819 // thread through a ThreadsListHandle to prevent it from exiting and
2820 // being reclaimed while we try to operate on it. The exceptions to this
2821 // rule are when operating on the current thread, or if the monitor of
2822 // the target java.lang.Thread is locked at the Java level - in both
2823 // cases the target cannot exit.
2824 
2825 static void thread_entry(JavaThread* thread, TRAPS) {
2826   HandleMark hm(THREAD);
2827   Handle obj(THREAD, thread-&gt;threadObj());
2828   JavaValue result(T_VOID);
2829   JavaCalls::call_virtual(&amp;result,
2830                           obj,
2831                           SystemDictionary::Thread_klass(),
2832                           vmSymbols::run_method_name(),
2833                           vmSymbols::void_method_signature(),
2834                           THREAD);
2835 }
2836 
2837 
2838 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
2839   JVMWrapper(&quot;JVM_StartThread&quot;);
2840   JavaThread *native_thread = NULL;
2841 
2842   // We cannot hold the Threads_lock when we throw an exception,
2843   // due to rank ordering issues. Example:  we might need to grab the
2844   // Heap_lock while we construct the exception.
2845   bool throw_illegal_thread_state = false;
2846 
2847   // We must release the Threads_lock before we can post a jvmti event
2848   // in Thread::start.
2849   {
2850     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
2851     // we operate.
2852     MutexLocker mu(Threads_lock);
2853 
2854     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
2855     // re-starting an already started thread, so we should usually find
2856     // that the JavaThread is null. However for a JNI attached thread
2857     // there is a small window between the Thread object being created
2858     // (with its JavaThread set) and the update to its threadStatus, so we
2859     // have to check for this
2860     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
2861       throw_illegal_thread_state = true;
2862     } else {
2863       // We could also check the stillborn flag to see if this thread was already stopped, but
2864       // for historical reasons we let the thread detect that itself when it starts running
2865 
2866       jlong size =
2867              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
2868       // Allocate the C++ Thread structure and create the native thread.  The
2869       // stack size retrieved from java is 64-bit signed, but the constructor takes
2870       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
2871       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
2872       //  - Avoid passing negative values which would result in really large stacks.
2873       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
2874       size_t sz = size &gt; 0 ? (size_t) size : 0;
2875       native_thread = new JavaThread(&amp;thread_entry, sz);
2876 
2877       // At this point it may be possible that no osthread was created for the
2878       // JavaThread due to lack of memory. Check for this situation and throw
2879       // an exception if necessary. Eventually we may want to change this so
2880       // that we only grab the lock if the thread was created successfully -
2881       // then we can also do this check and throw the exception in the
2882       // JavaThread constructor.
2883       if (native_thread-&gt;osthread() != NULL) {
2884         // Note: the current thread is not being used within &quot;prepare&quot;.
2885         native_thread-&gt;prepare(jthread);
2886       }
2887     }
2888   }
2889 
2890   if (throw_illegal_thread_state) {
2891     THROW(vmSymbols::java_lang_IllegalThreadStateException());
2892   }
2893 
2894   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
2895 
2896   if (native_thread-&gt;osthread() == NULL) {
2897     // No one should hold a reference to the &#39;native_thread&#39;.
2898     native_thread-&gt;smr_delete();
2899     if (JvmtiExport::should_post_resource_exhausted()) {
2900       JvmtiExport::post_resource_exhausted(
2901         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
2902         os::native_thread_creation_failed_msg());
2903     }
2904     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
2905               os::native_thread_creation_failed_msg());
2906   }
2907 
2908   Thread::start(native_thread);
2909 
2910 JVM_END
2911 
2912 
2913 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2914 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2915 // but is thought to be reliable and simple. In the case, where the receiver is the
2916 // same thread as the sender, no VM_Operation is needed.
2917 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2918   JVMWrapper(&quot;JVM_StopThread&quot;);
2919 
2920   // A nested ThreadsListHandle will grab the Threads_lock so create
2921   // tlh before we resolve throwable.
2922   ThreadsListHandle tlh(thread);
2923   oop java_throwable = JNIHandles::resolve(throwable);
2924   if (java_throwable == NULL) {
2925     THROW(vmSymbols::java_lang_NullPointerException());
2926   }
2927   oop java_thread = NULL;
2928   JavaThread* receiver = NULL;
2929   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2930   Events::log_exception(thread,
2931                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
2932                         p2i(receiver), p2i(java_thread), p2i(throwable));
2933 
2934   if (is_alive) {
2935     // jthread refers to a live JavaThread.
2936     if (thread == receiver) {
2937       // Exception is getting thrown at self so no VM_Operation needed.
2938       THROW_OOP(java_throwable);
2939     } else {
2940       // Use a VM_Operation to throw the exception.
2941       Thread::send_async_exception(java_thread, java_throwable);
2942     }
2943   } else {
2944     // Either:
2945     // - target thread has not been started before being stopped, or
2946     // - target thread already terminated
2947     // We could read the threadStatus to determine which case it is
2948     // but that is overkill as it doesn&#39;t matter. We must set the
2949     // stillborn flag for the first case, and if the thread has already
2950     // exited setting this flag has no effect.
2951     java_lang_Thread::set_stillborn(java_thread);
2952   }
2953 JVM_END
2954 
2955 
2956 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2957   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2958 
2959   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2960   return java_lang_Thread::is_alive(thread_oop);
2961 JVM_END
2962 
2963 
2964 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2965   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2966 
2967   ThreadsListHandle tlh(thread);
2968   JavaThread* receiver = NULL;
2969   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2970   if (is_alive) {
2971     // jthread refers to a live JavaThread.
2972     {
2973       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
2974       if (receiver-&gt;is_external_suspend()) {
2975         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2976         // an error from this interface so just ignore the problem.
2977         return;
2978       }
2979       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2980         return;
2981       }
2982       receiver-&gt;set_external_suspend();
2983     }
2984 
2985     // java_suspend() will catch threads in the process of exiting
2986     // and will ignore them.
2987     receiver-&gt;java_suspend();
2988 
2989     // It would be nice to have the following assertion in all the
2990     // time, but it is possible for a racing resume request to have
2991     // resumed this thread right after we suspended it. Temporarily
2992     // enable this assertion if you are chasing a different kind of
2993     // bug.
2994     //
2995     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
2996     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
2997   }
2998 JVM_END
2999 
3000 
3001 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3002   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3003 
3004   ThreadsListHandle tlh(thread);
3005   JavaThread* receiver = NULL;
3006   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3007   if (is_alive) {
3008     // jthread refers to a live JavaThread.
3009 
3010     // This is the original comment for this Threads_lock grab:
3011     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3012     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3013     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3014     //   looks at it.
3015     //
3016     // The above comment dates back to when we had both internal and
3017     // external suspend APIs that shared a common underlying mechanism.
3018     // External suspend is now entirely cooperative and doesn&#39;t share
3019     // anything with internal suspend. That said, there are some
3020     // assumptions in the VM that an external resume grabs the
3021     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3022     // resolve the assumptions that exist elsewhere.
3023     //
3024     MutexLocker ml(Threads_lock);
3025     receiver-&gt;java_resume();
3026   }
3027 JVM_END
3028 
3029 
3030 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3031   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3032 
3033   ThreadsListHandle tlh(thread);
3034   oop java_thread = NULL;
3035   JavaThread* receiver = NULL;
3036   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3037   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3038 
3039   if (is_alive) {
3040     // jthread refers to a live JavaThread.
3041     Thread::set_priority(receiver, (ThreadPriority)prio);
3042   }
3043   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3044   // priority set in the java.lang.Thread object above will be pushed
3045   // down when it does start.
3046 JVM_END
3047 
3048 
3049 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3050   JVMWrapper(&quot;JVM_Yield&quot;);
3051   if (os::dont_yield()) return;
3052   HOTSPOT_THREAD_YIELD();
3053   os::naked_yield();
3054 JVM_END
3055 
3056 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3057   assert(event != NULL, &quot;invariant&quot;);
3058   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3059   event-&gt;set_time(millis);
3060   event-&gt;commit();
3061 }
3062 
3063 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3064   JVMWrapper(&quot;JVM_Sleep&quot;);
3065 
3066   if (millis &lt; 0) {
3067     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3068   }
3069 
3070   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3071     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3072   }
3073 
3074   // Save current thread state and restore it at the end of this block.
3075   // And set new thread state to SLEEPING.
3076   JavaThreadSleepState jtss(thread);
3077 
3078   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3079   EventThreadSleep event;
3080 
3081   if (millis == 0) {
3082     os::naked_yield();
3083   } else {
3084     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3085     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3086     if (!thread-&gt;sleep(millis)) { // interrupted
3087       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3088       // us while we were sleeping. We do not overwrite those.
3089       if (!HAS_PENDING_EXCEPTION) {
3090         if (event.should_commit()) {
3091           post_thread_sleep_event(&amp;event, millis);
3092         }
3093         HOTSPOT_THREAD_SLEEP_END(1);
3094 
3095         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3096         // to properly restore the thread state.  That&#39;s likely wrong.
3097         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3098       }
3099     }
3100     thread-&gt;osthread()-&gt;set_state(old_state);
3101   }
3102   if (event.should_commit()) {
3103     post_thread_sleep_event(&amp;event, millis);
3104   }
3105   HOTSPOT_THREAD_SLEEP_END(0);
3106 JVM_END
3107 
3108 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3109   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3110   oop jthread = thread-&gt;threadObj();
3111   assert (thread != NULL, &quot;no current thread!&quot;);
3112   return JNIHandles::make_local(env, jthread);
3113 JVM_END
3114 
3115 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3116   JVMWrapper(&quot;JVM_Interrupt&quot;);
3117 
3118   ThreadsListHandle tlh(thread);
3119   JavaThread* receiver = NULL;
3120   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3121   if (is_alive) {
3122     // jthread refers to a live JavaThread.
3123     receiver-&gt;interrupt();
3124   }
3125 JVM_END
3126 
<a name="1" id="anc1"></a><span class="line-added">3127 JVM_ENTRY(jobject, JVM_ScopedCache(JNIEnv* env, jclass threadClass))</span>
<span class="line-added">3128   JVMWrapper(&quot;JVM_ScopedCache&quot;);</span>
<span class="line-added">3129   oop theCache = thread-&gt;_scopedCache;</span>
<span class="line-added">3130   if (theCache) {</span>
<span class="line-added">3131     arrayOop objs = arrayOop(theCache);</span>
<span class="line-added">3132     assert(objs-&gt;length() == ScopedCacheSize * 2, &quot;wrong length&quot;);</span>
<span class="line-added">3133   }</span>
<span class="line-added">3134   return JNIHandles::make_local(env, theCache);</span>
<span class="line-added">3135 JVM_END</span>
<span class="line-added">3136 </span>
<span class="line-added">3137 JVM_ENTRY(void, JVM_SetScopedCache(JNIEnv* env, jclass threadClass,</span>
<span class="line-added">3138                                    jobject theCache))</span>
<span class="line-added">3139   JVMWrapper(&quot;JVM_SetScopedCache&quot;);</span>
<span class="line-added">3140   arrayOop objs = arrayOop(JNIHandles::resolve(theCache));</span>
<span class="line-added">3141   if (objs != NULL) {</span>
<span class="line-added">3142     assert(objs-&gt;length() == ScopedCacheSize * 2, &quot;wrong length&quot;);</span>
<span class="line-added">3143   }</span>
<span class="line-added">3144   thread-&gt;_scopedCache = objs;</span>
<span class="line-added">3145 JVM_END</span>
3146 
3147 // Return true iff the current thread has locked the object passed in
3148 
3149 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3150   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3151   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3152   if (obj == NULL) {
3153     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3154   }
3155   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3156   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3157 JVM_END
3158 
3159 
3160 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3161   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3162   VM_PrintThreads op;
3163   VMThread::execute(&amp;op);
3164   if (JvmtiExport::should_post_data_dump()) {
3165     JvmtiExport::post_data_dump();
3166   }
3167 JVM_END
3168 
3169 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3170   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3171 
3172   // We don&#39;t use a ThreadsListHandle here because the current thread
3173   // must be alive.
3174   oop java_thread = JNIHandles::resolve_non_null(jthread);
3175   JavaThread* thr = java_lang_Thread::thread(java_thread);
3176   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3177     // Thread naming is only supported for the current thread and
3178     // we don&#39;t set the name of an attached thread to avoid stepping
3179     // on other programs.
3180     ResourceMark rm(thread);
3181     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3182     os::set_native_thread_name(thread_name);
3183   }
3184 JVM_END
3185 
3186 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3187 
3188 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3189   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3190   ResourceMark rm(THREAD);
3191   JvmtiVMObjectAllocEventCollector oam;
3192   vframeStream vfst(thread);
3193 
3194   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3195     // This must only be called from SecurityManager.getClassContext
3196     Method* m = vfst.method();
3197     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3198           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3199           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3200       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3201     }
3202   }
3203 
3204   // Collect method holders
3205   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3206   for (; !vfst.at_end(); vfst.security_next()) {
3207     Method* m = vfst.method();
3208     // Native frames are not returned
3209     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3210       Klass* holder = m-&gt;method_holder();
3211       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3212       klass_array-&gt;append(holder);
3213     }
3214   }
3215 
3216   // Create result array of type [Ljava/lang/Class;
3217   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3218   // Fill in mirrors corresponding to method holders
3219   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3220     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3221   }
3222 
3223   return (jobjectArray) JNIHandles::make_local(env, result);
3224 JVM_END
3225 
3226 
3227 // java.lang.Package ////////////////////////////////////////////////////////////////
3228 
3229 
3230 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3231   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3232   ResourceMark rm(THREAD);
3233   JvmtiVMObjectAllocEventCollector oam;
3234   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3235   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3236   return (jstring) JNIHandles::make_local(result);
3237 JVM_END
3238 
3239 
3240 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3241   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3242   JvmtiVMObjectAllocEventCollector oam;
3243   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3244   return (jobjectArray) JNIHandles::make_local(result);
3245 JVM_END
3246 
3247 
3248 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3249 
3250 
3251 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3252   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3253 
3254   MonitorLocker ml(Heap_lock);
3255   oop ref = Universe::reference_pending_list();
3256   if (ref != NULL) {
3257     Universe::set_reference_pending_list(NULL);
3258   }
3259   return JNIHandles::make_local(env, ref);
3260 JVM_END
3261 
3262 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3263   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3264   MonitorLocker ml(Heap_lock);
3265   return Universe::has_reference_pending_list();
3266 JVM_END
3267 
3268 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3269   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3270   MonitorLocker ml(Heap_lock);
3271   while (!Universe::has_reference_pending_list()) {
3272     ml.wait();
3273   }
3274 JVM_END
3275 
3276 
3277 // ObjectInputStream ///////////////////////////////////////////////////////////////
3278 
3279 // Return the first user-defined class loader up the execution stack, or null
3280 // if only code from the bootstrap or platform class loader is on the stack.
3281 
3282 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3283   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3284     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3285     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3286     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3287       return JNIHandles::make_local(env, loader);
3288     }
3289   }
3290   return NULL;
3291 JVM_END
3292 
3293 
3294 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3295 
3296 
3297 // resolve array handle and check arguments
3298 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3299   if (arr == NULL) {
3300     THROW_0(vmSymbols::java_lang_NullPointerException());
3301   }
3302   oop a = JNIHandles::resolve_non_null(arr);
3303   if (!a-&gt;is_array()) {
3304     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3305   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3306     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3307   }
3308   return arrayOop(a);
3309 }
3310 
3311 
3312 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3313   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3314   arrayOop a = check_array(env, arr, false, CHECK_0);
3315   return a-&gt;length();
3316 JVM_END
3317 
3318 
3319 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3320   JVMWrapper(&quot;JVM_Array_Get&quot;);
3321   JvmtiVMObjectAllocEventCollector oam;
3322   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3323   jvalue value;
3324   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3325   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3326   return JNIHandles::make_local(env, box);
3327 JVM_END
3328 
3329 
3330 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3331   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3332   jvalue value;
3333   value.i = 0; // to initialize value before getting used in CHECK
3334   arrayOop a = check_array(env, arr, true, CHECK_(value));
3335   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3336   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3337   BasicType wide_type = (BasicType) wCode;
3338   if (type != wide_type) {
3339     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3340   }
3341   return value;
3342 JVM_END
3343 
3344 
3345 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3346   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3347   arrayOop a = check_array(env, arr, false, CHECK);
3348   oop box = JNIHandles::resolve(val);
3349   jvalue value;
3350   value.i = 0; // to initialize value before getting used in CHECK
3351   BasicType value_type;
3352   if (a-&gt;is_objArray()) {
3353     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3354     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3355   } else {
3356     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3357   }
3358   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3359 JVM_END
3360 
3361 
3362 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3363   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3364   arrayOop a = check_array(env, arr, true, CHECK);
3365   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3366   BasicType value_type = (BasicType) vCode;
3367   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3368 JVM_END
3369 
3370 
3371 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3372   JVMWrapper(&quot;JVM_NewArray&quot;);
3373   JvmtiVMObjectAllocEventCollector oam;
3374   oop element_mirror = JNIHandles::resolve(eltClass);
3375   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3376   return JNIHandles::make_local(env, result);
3377 JVM_END
3378 
3379 
3380 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3381   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3382   JvmtiVMObjectAllocEventCollector oam;
3383   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3384   oop element_mirror = JNIHandles::resolve(eltClass);
3385   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3386   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3387   return JNIHandles::make_local(env, result);
3388 JVM_END
3389 
3390 
3391 // Library support ///////////////////////////////////////////////////////////////////////////
3392 
3393 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3394   //%note jvm_ct
3395   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3396   char ebuf[1024];
3397   void *load_result;
3398   {
3399     ThreadToNativeFromVM ttnfvm(thread);
3400     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3401   }
3402   if (load_result == NULL) {
3403     char msg[1024];
3404     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3405     // Since &#39;ebuf&#39; may contain a string encoded using
3406     // platform encoding scheme, we need to pass
3407     // Exceptions::unsafe_to_utf8 to the new_exception method
3408     // as the last argument. See bug 6367357.
3409     Handle h_exception =
3410       Exceptions::new_exception(thread,
3411                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3412                                 msg, Exceptions::unsafe_to_utf8);
3413 
3414     THROW_HANDLE_0(h_exception);
3415   }
3416   return load_result;
3417 JVM_END
3418 
3419 
3420 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3421   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3422   os::dll_unload(handle);
3423 JVM_END
3424 
3425 
3426 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3427   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3428   return os::dll_lookup(handle, name);
3429 JVM_END
3430 
3431 
3432 // JNI version ///////////////////////////////////////////////////////////////////////////////
3433 
3434 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3435   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3436   return Threads::is_supported_jni_version_including_1_1(version);
3437 JVM_END
3438 
3439 
3440 // String support ///////////////////////////////////////////////////////////////////////////
3441 
3442 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3443   JVMWrapper(&quot;JVM_InternString&quot;);
3444   JvmtiVMObjectAllocEventCollector oam;
3445   if (str == NULL) return NULL;
3446   oop string = JNIHandles::resolve_non_null(str);
3447   oop result = StringTable::intern(string, CHECK_NULL);
3448   return (jstring) JNIHandles::make_local(env, result);
3449 JVM_END
3450 
3451 
3452 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3453 
3454 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3455 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3456 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3457 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3458 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3459 
3460 
3461 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3462   VM_Exit::block_if_vm_exited();
3463   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3464   return new os::PlatformMutex();
3465 }
3466 
3467 
3468 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3469   VM_Exit::block_if_vm_exited();
3470   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3471   delete ((os::PlatformMutex*) mon);
3472 }
3473 
3474 
3475 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3476   VM_Exit::block_if_vm_exited();
3477   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3478   ((os::PlatformMutex*) mon)-&gt;lock();
3479   return 0;
3480 }
3481 
3482 
3483 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3484   VM_Exit::block_if_vm_exited();
3485   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3486   ((os::PlatformMutex*) mon)-&gt;unlock();
3487 }
3488 
3489 
3490 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3491 
3492 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3493                                     Handle loader, Handle protection_domain,
3494                                     jboolean throwError, TRAPS) {
3495   // Security Note:
3496   //   The Java level wrapper will perform the necessary security check allowing
3497   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3498   //   the checkPackageAccess relative to the initiating class loader via the
3499   //   protection_domain. The protection_domain is passed as NULL by the java code
3500   //   if there is no security manager in 3-arg Class.forName().
3501   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3502 
3503   // Check if we should initialize the class
3504   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3505     klass-&gt;initialize(CHECK_NULL);
3506   }
3507   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3508 }
3509 
3510 
3511 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3512 
3513 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3514   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3515   Handle method_handle;
3516   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3517     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3518     Handle receiver(THREAD, JNIHandles::resolve(obj));
3519     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3520     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3521     jobject res = JNIHandles::make_local(env, result);
3522     if (JvmtiExport::should_post_vm_object_alloc()) {
3523       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3524       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3525       if (java_lang_Class::is_primitive(ret_type)) {
3526         // Only for primitive type vm allocates memory for java object.
3527         // See box() method.
3528         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3529       }
3530     }
3531     return res;
3532   } else {
3533     THROW_0(vmSymbols::java_lang_StackOverflowError());
3534   }
3535 JVM_END
3536 
3537 
3538 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3539   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3540   oop constructor_mirror = JNIHandles::resolve(c);
3541   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3542   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3543   jobject res = JNIHandles::make_local(env, result);
3544   if (JvmtiExport::should_post_vm_object_alloc()) {
3545     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3546   }
3547   return res;
3548 JVM_END
3549 
3550 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3551 
3552 JVM_LEAF(jboolean, JVM_SupportsCX8())
3553   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3554   return VM_Version::supports_cx8();
3555 JVM_END
3556 
3557 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3558   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3559   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3560   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3561   HeapShared::initialize_from_archived_subgraph(k);
3562 JVM_END
3563 
3564 // Returns an array of all live Thread objects (VM internal JavaThreads,
3565 // jvmti agent threads, and JNI attaching threads  are skipped)
3566 // See CR 6404306 regarding JNI attaching threads
3567 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3568   ResourceMark rm(THREAD);
3569   ThreadsListEnumerator tle(THREAD, false, false);
3570   JvmtiVMObjectAllocEventCollector oam;
3571 
3572   int num_threads = tle.num_threads();
3573   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3574   objArrayHandle threads_ah(THREAD, r);
3575 
3576   for (int i = 0; i &lt; num_threads; i++) {
3577     Handle h = tle.get_threadObj(i);
3578     threads_ah-&gt;obj_at_put(i, h());
3579   }
3580 
3581   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3582 JVM_END
3583 
3584 
3585 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3586 // Return StackTraceElement[][], each element is the stack trace of a thread in
3587 // the corresponding entry in the given threads array
3588 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3589   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3590   JvmtiVMObjectAllocEventCollector oam;
3591 
3592   // Check if threads is null
3593   if (threads == NULL) {
3594     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3595   }
3596 
3597   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3598   objArrayHandle ah(THREAD, a);
3599   int num_threads = ah-&gt;length();
3600   // check if threads is non-empty array
3601   if (num_threads == 0) {
3602     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3603   }
3604 
3605   // check if threads is not an array of objects of Thread class
3606   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3607   if (k != SystemDictionary::Thread_klass()) {
3608     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3609   }
3610 
3611   ResourceMark rm(THREAD);
3612 
3613   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3614   for (int i = 0; i &lt; num_threads; i++) {
3615     oop thread_obj = ah-&gt;obj_at(i);
3616     instanceHandle h(THREAD, (instanceOop) thread_obj);
3617     thread_handle_array-&gt;append(h);
3618   }
3619 
3620   // The JavaThread references in thread_handle_array are validated
3621   // in VM_ThreadDump::doit().
3622   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3623   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3624 
3625 JVM_END
3626 
3627 // JVM monitoring and management support
3628 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3629   return Management::get_jmm_interface(version);
3630 JVM_END
3631 
3632 // com.sun.tools.attach.VirtualMachine agent properties support
3633 //
3634 // Initialize the agent properties with the properties maintained in the VM
3635 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3636   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3637   ResourceMark rm;
3638 
3639   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3640 
3641   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3642   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3643   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3644   return properties;
3645 JVM_END
3646 
3647 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3648 {
3649   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3650   JvmtiVMObjectAllocEventCollector oam;
3651 
3652   if (ofClass == NULL) {
3653     return NULL;
3654   }
3655   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3656   // Special handling for primitive objects
3657   if (java_lang_Class::is_primitive(mirror())) {
3658     return NULL;
3659   }
3660   Klass* k = java_lang_Class::as_Klass(mirror());
3661   if (!k-&gt;is_instance_klass()) {
3662     return NULL;
3663   }
3664   InstanceKlass* ik = InstanceKlass::cast(k);
3665   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3666   if (encl_method_class_idx == 0) {
3667     return NULL;
3668   }
3669   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3670   objArrayHandle dest(THREAD, dest_o);
3671   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3672   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3673   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3674   if (encl_method_method_idx != 0) {
3675     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3676                         extract_low_short_from_int(
3677                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3678     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3679     dest-&gt;obj_at_put(1, str());
3680     sym = ik-&gt;constants()-&gt;symbol_at(
3681               extract_high_short_from_int(
3682                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3683     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3684     dest-&gt;obj_at_put(2, str());
3685   }
3686   return (jobjectArray) JNIHandles::make_local(dest());
3687 }
3688 JVM_END
3689 
3690 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3691 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3692   ResourceMark rm(THREAD);
3693 
3694   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3695     return NULL;
3696   }
3697 
3698   char** vm_flags = Arguments::jvm_flags_array();
3699   char** vm_args = Arguments::jvm_args_array();
3700   int num_flags = Arguments::num_jvm_flags();
3701   int num_args = Arguments::num_jvm_args();
3702 
3703   InstanceKlass* ik = SystemDictionary::String_klass();
3704   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3705   objArrayHandle result_h(THREAD, r);
3706 
3707   int index = 0;
3708   for (int j = 0; j &lt; num_flags; j++, index++) {
3709     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3710     result_h-&gt;obj_at_put(index, h());
3711   }
3712   for (int i = 0; i &lt; num_args; i++, index++) {
3713     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3714     result_h-&gt;obj_at_put(index, h());
3715   }
3716   return (jobjectArray) JNIHandles::make_local(env, result_h());
3717 JVM_END
3718 
3719 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3720   return os::get_signal_number(name);
3721 JVM_END
3722 
3723 JVM_ENTRY(void, JVM_VirtualThreadStarted(JNIEnv* env, jclass vthread_class, jthread event_thread, jobject vthread))
3724   JVMWrapper(&quot;JVM_VirtualThreadStarted&quot;);
3725   if (JvmtiExport::should_post_vthread_scheduled()) {
3726     JvmtiExport::post_vthread_scheduled(event_thread, vthread);
3727   }
3728   JFR_ONLY(Jfr::on_thread_start(event_thread, vthread));
3729 JVM_END
3730 
3731 JVM_ENTRY(void, JVM_VirtualThreadTerminated(JNIEnv* env, jclass vthread_class, jthread event_thread, jobject vthread))
3732   JVMWrapper(&quot;JVM_VirtualThreadTerminated&quot;);
3733   if (JvmtiExport::should_post_vthread_terminated()) {
3734     JvmtiExport::post_vthread_terminated(event_thread, vthread);
3735   }
3736   JFR_ONLY(Jfr::on_thread_exit(event_thread, vthread));
3737 JVM_END
3738 
3739 JVM_ENTRY(void, JVM_VirtualThreadMount(JNIEnv* env, jclass vthread_class, jthread event_thread, jobject vthread))
3740   JVMWrapper(&quot;JVM_VirtualThreadMount&quot;);
3741   if (JvmtiExport::should_post_vthread_mounted()) {
3742     JvmtiExport::post_vthread_mounted(event_thread, vthread);
3743   }
3744 JVM_END
3745 
3746 JVM_ENTRY(void, JVM_VirtualThreadUnmount(JNIEnv* env, jclass vthread_class, jthread event_thread, jobject vthread))
3747   JVMWrapper(&quot;JVM_VirtualThreadUnmount&quot;);
3748   if (JvmtiExport::should_post_vthread_unmounted()) {
3749     JvmtiExport::post_vthread_unmounted(event_thread, vthread);
3750   }
3751 JVM_END
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>