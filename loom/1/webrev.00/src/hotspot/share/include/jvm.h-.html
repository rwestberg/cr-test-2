<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable, jobject contScope);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
 194 /*
 195  * java.lang.NullPointerException
 196  */
 197 
 198 JNIEXPORT jstring JNICALL
 199 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 200 
 201 /*
 202  * java.lang.StackWalker
 203  */
 204 enum {
 205   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 206   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 207   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 208   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 209 };
 210 
 211 JNIEXPORT jobject JNICALL
 212 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 213                   jint skip_frames, jobject contScope, jobject cont,
 214                   jint frame_count, jint start_index, jobjectArray frames);
 215 
 216 JNIEXPORT jint JNICALL
 217 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor, 
 218                   jint frame_count, jint start_index, 
 219                   jobjectArray frames);
 220 
 221 JNIEXPORT void JNICALL
 222 JVM_SetStackWalkContinuation(JNIEnv *env, jobject stackStream, jlong anchor, jobjectArray frames, jobject cont);
 223 
 224 /*
 225  * java.lang.Thread
 226  */
 227 JNIEXPORT void JNICALL
 228 JVM_StartThread(JNIEnv *env, jobject thread);
 229 
 230 JNIEXPORT void JNICALL
 231 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 232 
 233 JNIEXPORT jboolean JNICALL
 234 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_SuspendThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_ResumeThread(JNIEnv *env, jobject thread);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Yield(JNIEnv *env, jclass threadClass);
 247 
 248 JNIEXPORT void JNICALL
 249 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 250 
 251 JNIEXPORT jobject JNICALL
 252 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 253 
 254 JNIEXPORT void JNICALL
 255 JVM_Interrupt(JNIEnv *env, jobject thread);
 256 
 257 JNIEXPORT jboolean JNICALL
 258 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 259 
 260 JNIEXPORT void JNICALL
 261 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 262 
 263 JNIEXPORT jobjectArray JNICALL
 264 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 268 
 269 /* getStackTrace() and getAllStackTraces() method */
 270 JNIEXPORT jobjectArray JNICALL
 271 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 272 
 273 /*
 274  * java.lang.Continuation
 275  */
 276 JNIEXPORT void JNICALL
 277 JVM_RegisterContinuationMethods(JNIEnv *env, jclass cls);
 278 
 279 /*
 280  * java.lang.SecurityManager
 281  */
 282 JNIEXPORT jobjectArray JNICALL
 283 JVM_GetClassContext(JNIEnv *env);
 284 
 285 /*
 286  * java.lang.Package
 287  */
 288 JNIEXPORT jstring JNICALL
 289 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 290 
 291 JNIEXPORT jobjectArray JNICALL
 292 JVM_GetSystemPackages(JNIEnv *env);
 293 
 294 /*
 295  * java.lang.ref.Reference
 296  */
 297 JNIEXPORT jobject JNICALL
 298 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 299 
 300 JNIEXPORT jboolean JNICALL
 301 JVM_HasReferencePendingList(JNIEnv *env);
 302 
 303 JNIEXPORT void JNICALL
 304 JVM_WaitForReferencePendingList(JNIEnv *env);
 305 
 306 /*
 307  * java.io.ObjectInputStream
 308  */
 309 JNIEXPORT jobject JNICALL
 310 JVM_LatestUserDefinedLoader(JNIEnv *env);
 311 
 312 /*
 313  * java.lang.reflect.Array
 314  */
 315 JNIEXPORT jint JNICALL
 316 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 317 
 318 JNIEXPORT jobject JNICALL
 319 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 320 
 321 JNIEXPORT jvalue JNICALL
 322 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 323 
 324 JNIEXPORT void JNICALL
 325 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 326 
 327 JNIEXPORT void JNICALL
 328 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 329                              unsigned char vCode);
 330 
 331 JNIEXPORT jobject JNICALL
 332 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 333 
 334 JNIEXPORT jobject JNICALL
 335 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 336 
 337 
 338 /*
 339  * Returns the immediate caller class of the native method invoking
 340  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 341  * reflection machinery are skipped.
 342  *
 343  * The caller is expected to be marked with
 344  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 345  * error if it is not marked properly.
 346  */
 347 JNIEXPORT jclass JNICALL
 348 JVM_GetCallerClass(JNIEnv *env);
 349 
 350 
 351 /*
 352  * Find primitive classes
 353  * utf: class name
 354  */
 355 JNIEXPORT jclass JNICALL
 356 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 357 
 358 
 359 /*
 360  * Find a class from a boot class loader. Returns NULL if class not found.
 361  */
 362 JNIEXPORT jclass JNICALL
 363 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 364 
 365 /*
 366  * Find a class from a given class loader.  Throws ClassNotFoundException.
 367  *  name:   name of class
 368  *  init:   whether initialization is done
 369  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 370  *          class loader.
 371  *  caller: initiating class. The initiating class may be null when a security
 372  *          manager is not installed.
 373  */
 374 JNIEXPORT jclass JNICALL
 375 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 376                         jobject loader, jclass caller);
 377 
 378 /*
 379  * Find a class from a given class.
 380  */
 381 JNIEXPORT jclass JNICALL
 382 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 383                              jclass from);
 384 
 385 /* Find a loaded class cached by the VM */
 386 JNIEXPORT jclass JNICALL
 387 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 388 
 389 /* Define a class */
 390 JNIEXPORT jclass JNICALL
 391 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 392                 jsize len, jobject pd);
 393 
 394 /* Define a class with a source (added in JDK1.5) */
 395 JNIEXPORT jclass JNICALL
 396 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 397                           const jbyte *buf, jsize len, jobject pd,
 398                           const char *source);
 399 
 400 /*
 401  * Module support funcions
 402  */
 403 
 404 /*
 405  * Define a module with the specified packages and bind the module to the
 406  * given class loader.
 407  *  module:       module to define
 408  *  is_open:      specifies if module is open (currently ignored)
 409  *  version:      the module version
 410  *  location:     the module location
 411  *  packages:     list of packages in the module
 412  *  num_packages: number of packages in the module
 413  */
 414 JNIEXPORT void JNICALL
 415 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 416                  jstring location, const char* const* packages, jsize num_packages);
 417 
 418 /*
 419  * Set the boot loader&#39;s unnamed module.
 420  *  module: boot loader&#39;s unnamed module
 421  */
 422 JNIEXPORT void JNICALL
 423 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 424 
 425 /*
 426  * Do a qualified export of a package.
 427  *  from_module: module containing the package to export
 428  *  package:     name of the package to export
 429  *  to_module:   module to export the package to
 430  */
 431 JNIEXPORT void JNICALL
 432 JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);
 433 
 434 /*
 435  * Do an export of a package to all unnamed modules.
 436  *  from_module: module containing the package to export
 437  *  package:     name of the package to export to all unnamed modules
 438  */
 439 JNIEXPORT void JNICALL
 440 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);
 441 
 442 /*
 443  * Do an unqualified export of a package.
 444  *  from_module: module containing the package to export
 445  *  package:     name of the package to export
 446  */
 447 JNIEXPORT void JNICALL
 448 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);
 449 
 450 /*
 451  * Add a module to the list of modules that a given module can read.
 452  *  from_module:   module requesting read access
 453  *  source_module: module that from_module wants to read
 454  */
 455 JNIEXPORT void JNICALL
 456 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 457 
 458 /*
 459  * Reflection support functions
 460  */
 461 
 462 JNIEXPORT jstring JNICALL
 463 JVM_InitClassName(JNIEnv *env, jclass cls);
 464 
 465 JNIEXPORT jobjectArray JNICALL
 466 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 467 
 468 JNIEXPORT jboolean JNICALL
 469 JVM_IsInterface(JNIEnv *env, jclass cls);
 470 
 471 JNIEXPORT jobjectArray JNICALL
 472 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 473 
 474 JNIEXPORT void JNICALL
 475 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 476 
 477 JNIEXPORT jobject JNICALL
 478 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 479 
 480 JNIEXPORT jboolean JNICALL
 481 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 482 
 483 JNIEXPORT jboolean JNICALL
 484 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 485 
 486 JNIEXPORT jint JNICALL
 487 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 488 
 489 JNIEXPORT jobjectArray JNICALL
 490 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 491 
 492 JNIEXPORT jclass JNICALL
 493 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 494 
 495 JNIEXPORT jstring JNICALL
 496 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 497 
 498 /* Generics support (JDK 1.5) */
 499 JNIEXPORT jstring JNICALL
 500 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 501 
 502 /* Annotations support (JDK 1.5) */
 503 JNIEXPORT jbyteArray JNICALL
 504 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 505 
 506 /* Type use annotations support (JDK 1.8) */
 507 
 508 JNIEXPORT jbyteArray JNICALL
 509 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 510 
 511 JNIEXPORT jbyteArray JNICALL
 512 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 513 
 514 JNIEXPORT jbyteArray JNICALL
 515 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 516 
 517 /*
 518  * New (JDK 1.4) reflection implementation
 519  */
 520 
 521 JNIEXPORT jobjectArray JNICALL
 522 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 523 
 524 JNIEXPORT jobjectArray JNICALL
 525 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 526 
 527 JNIEXPORT jobjectArray JNICALL
 528 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 529 
 530 
 531 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 532    This returns the access flags for the class as specified in the
 533    class file rather than searching the InnerClasses attribute (if
 534    present) to find the source-level access flags. Only the values of
 535    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 536    valid. */
 537 JNIEXPORT jint JNICALL
 538 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 539 
 540 /* Nestmates - since JDK 11 */
 541 
 542 JNIEXPORT jboolean JNICALL
 543 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 544 
 545 JNIEXPORT jclass JNICALL
 546 JVM_GetNestHost(JNIEnv *env, jclass current);
 547 
 548 JNIEXPORT jobjectArray JNICALL
 549 JVM_GetNestMembers(JNIEnv *env, jclass current);
 550 
 551 /* Records - since JDK 14 */
 552 
 553 JNIEXPORT jboolean JNICALL
 554 JVM_IsRecord(JNIEnv *env, jclass cls);
 555 
 556 JNIEXPORT jobjectArray JNICALL
 557 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 558 
 559 /* The following two reflection routines are still needed due to startup time issues */
 560 /*
 561  * java.lang.reflect.Method
 562  */
 563 JNIEXPORT jobject JNICALL
 564 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 565 
 566 /*
 567  * java.lang.reflect.Constructor
 568  */
 569 JNIEXPORT jobject JNICALL
 570 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 571 
 572 /*
 573  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 574  */
 575 
 576 JNIEXPORT jobject JNICALL
 577 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 578 
 579 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 580 (JNIEnv *env, jobject unused, jobject jcpool);
 581 
 582 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 583 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 584 
 585 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 586 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 587 
 588 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 589 (JNIEnv *env, jobject obj, jobject unused, jint index);
 590 
 591 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 592 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 593 
 594 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 595 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 596 
 597 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 598 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 599 
 600 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 601 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 602 
 603 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 604 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 605 
 606 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 607 (JNIEnv *env, jobject obj, jobject unused, jint index);
 608 
 609 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 610 (JNIEnv *env, jobject obj, jobject unused, jint index);
 611 
 612 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 613 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 614 
 615 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 616 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 617 
 618 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 619 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 620 
 621 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 622 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 623 
 624 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 625 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 626 
 627 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 628 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 629 
 630 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 631 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 632 
 633 /*
 634  * Parameter reflection
 635  */
 636 
 637 JNIEXPORT jobjectArray JNICALL
 638 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 639 
 640 /*
 641  * java.security.*
 642  */
 643 
 644 JNIEXPORT jobject JNICALL
 645 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 646 
 647 /*
 648  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 649  * get the value will see a materialized value and not a scalar-replaced
 650  * null value.
 651  */
 652 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 653     do {} while(0) // Nothing to do.  The fact that the value escaped
 654                    // through a native method is enough.
 655 
 656 JNIEXPORT jobject JNICALL
 657 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 658 
 659 /*
 660  * Signal support, used to implement the shutdown sequence.  Every VM must
 661  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 662  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 663  * Other platform-dependent signal values may also be supported.
 664  */
 665 
 666 JNIEXPORT void * JNICALL
 667 JVM_RegisterSignal(jint sig, void *handler);
 668 
 669 JNIEXPORT jboolean JNICALL
 670 JVM_RaiseSignal(jint sig);
 671 
 672 JNIEXPORT jint JNICALL
 673 JVM_FindSignal(const char *name);
 674 
 675 /*
 676  * Retrieve the assertion directives for the specified class.
 677  */
 678 JNIEXPORT jboolean JNICALL
 679 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 680 
 681 /*
 682  * Retrieve the assertion directives from the VM.
 683  */
 684 JNIEXPORT jobject JNICALL
 685 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 686 
 687 /*
 688  * java.util.concurrent.atomic.AtomicLong
 689  */
 690 JNIEXPORT jboolean JNICALL
 691 JVM_SupportsCX8(void);
 692 
 693 /*
 694  * com.sun.dtrace.jsdt support
 695  */
 696 
 697 #define JVM_TRACING_DTRACE_VERSION 1
 698 
 699 /*
 700  * Structure to pass one probe description to JVM
 701  */
 702 typedef struct {
 703     jmethodID method;
 704     jstring   function;
 705     jstring   name;
 706     void*            reserved[4];     // for future use
 707 } JVM_DTraceProbe;
 708 
 709 /**
 710  * Encapsulates the stability ratings for a DTrace provider field
 711  */
 712 typedef struct {
 713     jint nameStability;
 714     jint dataStability;
 715     jint dependencyClass;
 716 } JVM_DTraceInterfaceAttributes;
 717 
 718 /*
 719  * Structure to pass one provider description to JVM
 720  */
 721 typedef struct {
 722     jstring                       name;
 723     JVM_DTraceProbe*              probes;
 724     jint                          probe_count;
 725     JVM_DTraceInterfaceAttributes providerAttributes;
 726     JVM_DTraceInterfaceAttributes moduleAttributes;
 727     JVM_DTraceInterfaceAttributes functionAttributes;
 728     JVM_DTraceInterfaceAttributes nameAttributes;
 729     JVM_DTraceInterfaceAttributes argsAttributes;
 730     void*                         reserved[4]; // for future use
 731 } JVM_DTraceProvider;
 732 
 733 /*
 734  * Get the version number the JVM was built with
 735  */
 736 JNIEXPORT jint JNICALL
 737 JVM_DTraceGetVersion(JNIEnv* env);
 738 
 739 /*
 740  * Register new probe with given signature, return global handle
 741  *
 742  * The version passed in is the version that the library code was
 743  * built with.
 744  */
 745 JNIEXPORT jlong JNICALL
 746 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 747   jint providers_count, JVM_DTraceProvider* providers);
 748 
 749 /*
 750  * Check JSDT probe
 751  */
 752 JNIEXPORT jboolean JNICALL
 753 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 754 
 755 /*
 756  * Destroy custom DOF
 757  */
 758 JNIEXPORT void JNICALL
 759 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 760 
 761 /*
 762  * Check to see if DTrace is supported by OS
 763  */
 764 JNIEXPORT jboolean JNICALL
 765 JVM_DTraceIsSupported(JNIEnv* env);
 766 
 767 /*************************************************************************
 768  PART 2: Support for the Verifier and Class File Format Checker
 769  ************************************************************************/
 770 /*
 771  * Return the class name in UTF format. The result is valid
 772  * until JVM_ReleaseUTf is called.
 773  *
 774  * The caller must treat the string as a constant and not modify it
 775  * in any way.
 776  */
 777 JNIEXPORT const char * JNICALL
 778 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 779 
 780 /*
 781  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 782  */
 783 JNIEXPORT void JNICALL
 784 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 785 
 786 /*
 787  * Returns the number of Constant Pool entries.
 788  */
 789 JNIEXPORT jint JNICALL
 790 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 791 
 792 /*
 793  * Returns the number of *declared* fields or methods.
 794  */
 795 JNIEXPORT jint JNICALL
 796 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 797 
 798 JNIEXPORT jint JNICALL
 799 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 800 
 801 /*
 802  * Returns the CP indexes of exceptions raised by a given method.
 803  * Places the result in the given buffer.
 804  *
 805  * The method is identified by method_index.
 806  */
 807 JNIEXPORT void JNICALL
 808 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 809                                 unsigned short *exceptions);
 810 /*
 811  * Returns the number of exceptions raised by a given method.
 812  * The method is identified by method_index.
 813  */
 814 JNIEXPORT jint JNICALL
 815 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 816 
 817 /*
 818  * Returns the byte code sequence of a given method.
 819  * Places the result in the given buffer.
 820  *
 821  * The method is identified by method_index.
 822  */
 823 JNIEXPORT void JNICALL
 824 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 825                         unsigned char *code);
 826 
 827 /*
 828  * Returns the length of the byte code sequence of a given method.
 829  * The method is identified by method_index.
 830  */
 831 JNIEXPORT jint JNICALL
 832 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 833 
 834 /*
 835  * A structure used to a capture exception table entry in a Java method.
 836  */
 837 typedef struct {
 838     jint start_pc;
 839     jint end_pc;
 840     jint handler_pc;
 841     jint catchType;
 842 } JVM_ExceptionTableEntryType;
 843 
 844 /*
 845  * Returns the exception table entry at entry_index of a given method.
 846  * Places the result in the given buffer.
 847  *
 848  * The method is identified by method_index.
 849  */
 850 JNIEXPORT void JNICALL
 851 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 852                                    jint entry_index,
 853                                    JVM_ExceptionTableEntryType *entry);
 854 
 855 /*
 856  * Returns the length of the exception table of a given method.
 857  * The method is identified by method_index.
 858  */
 859 JNIEXPORT jint JNICALL
 860 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 861 
 862 /*
 863  * Returns the modifiers of a given field.
 864  * The field is identified by field_index.
 865  */
 866 JNIEXPORT jint JNICALL
 867 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 868 
 869 /*
 870  * Returns the modifiers of a given method.
 871  * The method is identified by method_index.
 872  */
 873 JNIEXPORT jint JNICALL
 874 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 875 
 876 /*
 877  * Returns the number of local variables of a given method.
 878  * The method is identified by method_index.
 879  */
 880 JNIEXPORT jint JNICALL
 881 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 882 
 883 /*
 884  * Returns the number of arguments (including this pointer) of a given method.
 885  * The method is identified by method_index.
 886  */
 887 JNIEXPORT jint JNICALL
 888 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 889 
 890 /*
 891  * Returns the maximum amount of stack (in words) used by a given method.
 892  * The method is identified by method_index.
 893  */
 894 JNIEXPORT jint JNICALL
 895 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 896 
 897 /*
 898  * Is a given method a constructor.
 899  * The method is identified by method_index.
 900  */
 901 JNIEXPORT jboolean JNICALL
 902 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 903 
 904 /*
 905  * Is the given method generated by the VM.
 906  * The method is identified by method_index.
 907  */
 908 JNIEXPORT jboolean JNICALL
 909 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 910 
 911 /*
 912  * Returns the name of a given method in UTF format.
 913  * The result remains valid until JVM_ReleaseUTF is called.
 914  *
 915  * The caller must treat the string as a constant and not modify it
 916  * in any way.
 917  */
 918 JNIEXPORT const char * JNICALL
 919 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 920 
 921 /*
 922  * Returns the signature of a given method in UTF format.
 923  * The result remains valid until JVM_ReleaseUTF is called.
 924  *
 925  * The caller must treat the string as a constant and not modify it
 926  * in any way.
 927  */
 928 JNIEXPORT const char * JNICALL
 929 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 930 
 931 /*
 932  * Returns the name of the field referred to at a given constant pool
 933  * index.
 934  *
 935  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 936  * is called.
 937  *
 938  * The caller must treat the string as a constant and not modify it
 939  * in any way.
 940  */
 941 JNIEXPORT const char * JNICALL
 942 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 943 
 944 /*
 945  * Returns the name of the method referred to at a given constant pool
 946  * index.
 947  *
 948  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 949  * is called.
 950  *
 951  * The caller must treat the string as a constant and not modify it
 952  * in any way.
 953  */
 954 JNIEXPORT const char * JNICALL
 955 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 956 
 957 /*
 958  * Returns the signature of the method referred to at a given constant pool
 959  * index.
 960  *
 961  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 962  * is called.
 963  *
 964  * The caller must treat the string as a constant and not modify it
 965  * in any way.
 966  */
 967 JNIEXPORT const char * JNICALL
 968 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 969 
 970 /*
 971  * Returns the signature of the field referred to at a given constant pool
 972  * index.
 973  *
 974  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 975  * is called.
 976  *
 977  * The caller must treat the string as a constant and not modify it
 978  * in any way.
 979  */
 980 JNIEXPORT const char * JNICALL
 981 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 982 
 983 /*
 984  * Returns the class name referred to at a given constant pool index.
 985  *
 986  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 987  * is called.
 988  *
 989  * The caller must treat the string as a constant and not modify it
 990  * in any way.
 991  */
 992 JNIEXPORT const char * JNICALL
 993 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
 994 
 995 /*
 996  * Returns the class name referred to at a given constant pool index.
 997  *
 998  * The constant pool entry must refer to a CONSTANT_Fieldref.
 999  *
1000  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1001  * is called.
1002  *
1003  * The caller must treat the string as a constant and not modify it
1004  * in any way.
1005  */
1006 JNIEXPORT const char * JNICALL
1007 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1008 
1009 /*
1010  * Returns the class name referred to at a given constant pool index.
1011  *
1012  * The constant pool entry must refer to CONSTANT_Methodref or
1013  * CONSTANT_InterfaceMethodref.
1014  *
1015  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1016  * is called.
1017  *
1018  * The caller must treat the string as a constant and not modify it
1019  * in any way.
1020  */
1021 JNIEXPORT const char * JNICALL
1022 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1023 
1024 /*
1025  * Returns the modifiers of a field in calledClass. The field is
1026  * referred to in class cb at constant pool entry index.
1027  *
1028  * The caller must treat the string as a constant and not modify it
1029  * in any way.
1030  *
1031  * Returns -1 if the field does not exist in calledClass.
1032  */
1033 JNIEXPORT jint JNICALL
1034 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1035 
1036 /*
1037  * Returns the modifiers of a method in calledClass. The method is
1038  * referred to in class cb at constant pool entry index.
1039  *
1040  * Returns -1 if the method does not exist in calledClass.
1041  */
1042 JNIEXPORT jint JNICALL
1043 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1044 
1045 /*
1046  * Releases the UTF string obtained from the VM.
1047  */
1048 JNIEXPORT void JNICALL
1049 JVM_ReleaseUTF(const char *utf);
1050 
1051 /*
1052  * Compare if two classes are in the same package.
1053  */
1054 JNIEXPORT jboolean JNICALL
1055 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1056 
1057 /* Get classfile constants */
1058 #include &quot;classfile_constants.h&quot;
1059 
1060 /*
1061  * Support for a VM-independent class format checker.
1062  */
1063 typedef struct {
1064     unsigned long code;    /* byte code */
1065     unsigned long excs;    /* exceptions */
1066     unsigned long etab;    /* catch table */
1067     unsigned long lnum;    /* line number */
1068     unsigned long lvar;    /* local vars */
1069 } method_size_info;
1070 
1071 typedef struct {
1072     unsigned int constants;    /* constant pool */
1073     unsigned int fields;
1074     unsigned int methods;
1075     unsigned int interfaces;
1076     unsigned int fields2;      /* number of static 2-word fields */
1077     unsigned int innerclasses; /* # of records in InnerClasses attr */
1078 
1079     method_size_info clinit;   /* memory used in clinit */
1080     method_size_info main;     /* used everywhere else */
1081 } class_size_info;
1082 
1083 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1084                                         JVM_ACC_FINAL | \
1085                                         JVM_ACC_SUPER | \
1086                                         JVM_ACC_INTERFACE | \
1087                                         JVM_ACC_ABSTRACT | \
1088                                         JVM_ACC_ANNOTATION | \
1089                                         JVM_ACC_ENUM | \
1090                                         JVM_ACC_SYNTHETIC)
1091 
1092 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1093                                         JVM_ACC_PRIVATE | \
1094                                         JVM_ACC_PROTECTED | \
1095                                         JVM_ACC_STATIC | \
1096                                         JVM_ACC_FINAL | \
1097                                         JVM_ACC_VOLATILE | \
1098                                         JVM_ACC_TRANSIENT | \
1099                                         JVM_ACC_ENUM | \
1100                                         JVM_ACC_SYNTHETIC)
1101 
1102 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1103                                          JVM_ACC_PRIVATE | \
1104                                          JVM_ACC_PROTECTED | \
1105                                          JVM_ACC_STATIC | \
1106                                          JVM_ACC_FINAL | \
1107                                          JVM_ACC_SYNCHRONIZED | \
1108                                          JVM_ACC_BRIDGE | \
1109                                          JVM_ACC_VARARGS | \
1110                                          JVM_ACC_NATIVE | \
1111                                          JVM_ACC_ABSTRACT | \
1112                                          JVM_ACC_STRICT | \
1113                                          JVM_ACC_SYNTHETIC)
1114 
1115 
1116 /*************************************************************************
1117  PART 3: I/O and Network Support
1118  ************************************************************************/
1119 
1120 /*
1121  * Convert a pathname into native format.  This function does syntactic
1122  * cleanup, such as removing redundant separator characters.  It modifies
1123  * the given pathname string in place.
1124  */
1125 JNIEXPORT char * JNICALL
1126 JVM_NativePath(char *);
1127 
1128 /*
1129  * The standard printing functions supported by the Java VM. (Should they
1130  * be renamed to JVM_* in the future?
1131  */
1132 
1133 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1134  *  respectively, with the following differences:
1135  * - The string written to str is always zero-terminated, also in case of
1136  *   truncation (count is too small to hold the result string), unless count
1137  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1138  *   appendend.
1139  * - If count is too small to hold the whole string, -1 is returned across
1140  *   all platforms. */
1141 
1142 JNIEXPORT int
1143 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1144 
1145 JNIEXPORT int
1146 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1147 
1148 JNIEXPORT int
1149 jio_fprintf(FILE *, const char *fmt, ...);
1150 
1151 JNIEXPORT int
1152 jio_vfprintf(FILE *, const char *fmt, va_list args);
1153 
1154 
1155 JNIEXPORT void * JNICALL
1156 JVM_RawMonitorCreate(void);
1157 
1158 JNIEXPORT void JNICALL
1159 JVM_RawMonitorDestroy(void *mon);
1160 
1161 JNIEXPORT jint JNICALL
1162 JVM_RawMonitorEnter(void *mon);
1163 
1164 JNIEXPORT void JNICALL
1165 JVM_RawMonitorExit(void *mon);
1166 
1167 /*
1168  * java.lang.management support
1169  */
1170 JNIEXPORT void* JNICALL
1171 JVM_GetManagement(jint version);
1172 
1173 /*
1174  * com.sun.tools.attach.VirtualMachine support
1175  *
1176  * Initialize the agent properties with the properties maintained in the VM.
1177  */
1178 JNIEXPORT jobject JNICALL
1179 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1180 
1181 JNIEXPORT jstring JNICALL
1182 JVM_GetTemporaryDirectory(JNIEnv *env);
1183 
1184 /* Generics reflection support.
1185  *
1186  * Returns information about the given class&#39;s EnclosingMethod
1187  * attribute, if present, or null if the class had no enclosing
1188  * method.
1189  *
1190  * If non-null, the returned array contains three elements. Element 0
1191  * is the java.lang.Class of which the enclosing method is a member,
1192  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1193  * method&#39;s name and descriptor, respectively.
1194  */
1195 JNIEXPORT jobjectArray JNICALL
1196 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1197     
1198 /* Virtual thread support.
1199  */
1200 JNIEXPORT void JNICALL
1201 JVM_VirtualThreadStarted(JNIEnv* env, jclass vthread_class, jobject event_thread, jobject vthread);
1202 
1203 JNIEXPORT void JNICALL
1204 JVM_VirtualThreadTerminated(JNIEnv* env, jclass vthread_class, jobject event_hread, jobject vthread);
1205 
1206 JNIEXPORT void JNICALL
1207 JVM_VirtualThreadMount(JNIEnv* env, jclass vthread_class, jobject event_thread, jobject vthread);
1208 
1209 JNIEXPORT void JNICALL
1210 JVM_VirtualThreadUnmount(JNIEnv* env, jclass vthread_class, jobject event_hread, jobject vthread);
1211 
1212 /*
1213  * This structure is used by the launcher to get the default thread
1214  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1215  * version of 1.1.  As it is not supported otherwise, it has been removed
1216  * from jni.h
1217  */
1218 typedef struct JDK1_1InitArgs {
1219     jint version;
1220 
1221     char **properties;
1222     jint checkSource;
1223     jint nativeStackSize;
1224     jint javaStackSize;
1225     jint minHeapSize;
1226     jint maxHeapSize;
1227     jint verifyMode;
1228     char *classpath;
1229 
1230     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1231     void (JNICALL *exit)(jint code);
1232     void (JNICALL *abort)(void);
1233 
1234     jint enableClassGC;
1235     jint enableVerboseGC;
1236     jint disableAsyncGC;
1237     jint verbose;
1238     jboolean debugging;
1239     jint debugPort;
1240 } JDK1_1InitArgs;
1241 
1242 
1243 #ifdef __cplusplus
1244 } /* extern &quot;C&quot; */
1245 
1246 #endif /* __cplusplus */
1247 
1248 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>