<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable, jobject contScope);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
 194 /*
 195  * java.lang.NullPointerException
 196  */
 197 
 198 JNIEXPORT jstring JNICALL
 199 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 200 
 201 /*
 202  * java.lang.StackWalker
 203  */
 204 enum {
 205   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 206   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 207   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 208   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 209 };
 210 
 211 JNIEXPORT jobject JNICALL
 212 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 213                   jint skip_frames, jobject contScope, jobject cont,
 214                   jint frame_count, jint start_index, jobjectArray frames);
 215 
 216 JNIEXPORT jobject JNICALL
 217 JVM_ScopedCache(JNIEnv *env, jclass threadClass);
 218 
 219 JNIEXPORT void JNICALL
 220 JVM_SetScopedCache(JNIEnv *env, jclass threadClass, jobject theCache);
 221 
 222 JNIEXPORT jint JNICALL
 223 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor, 
 224                   jint frame_count, jint start_index, 
 225                   jobjectArray frames);
 226 
 227 JNIEXPORT void JNICALL
 228 JVM_SetStackWalkContinuation(JNIEnv *env, jobject stackStream, jlong anchor, jobjectArray frames, jobject cont);
 229 
 230 /*
 231  * java.lang.Thread
 232  */
 233 JNIEXPORT void JNICALL
 234 JVM_StartThread(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 238 
 239 JNIEXPORT jboolean JNICALL
 240 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_SuspendThread(JNIEnv *env, jobject thread);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_ResumeThread(JNIEnv *env, jobject thread);
 247 
 248 JNIEXPORT void JNICALL
 249 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 250 
 251 JNIEXPORT void JNICALL
 252 JVM_Yield(JNIEnv *env, jclass threadClass);
 253 
 254 JNIEXPORT void JNICALL
 255 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 256 
 257 JNIEXPORT jobject JNICALL
 258 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 259 
 260 JNIEXPORT void JNICALL
 261 JVM_Interrupt(JNIEnv *env, jobject thread);
 262 
 263 JNIEXPORT jboolean JNICALL
 264 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 265 
 266 JNIEXPORT void JNICALL
 267 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 268 
 269 JNIEXPORT jobjectArray JNICALL
 270 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 271 
 272 JNIEXPORT void JNICALL
 273 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 274 
 275 /* getStackTrace() and getAllStackTraces() method */
 276 JNIEXPORT jobjectArray JNICALL
 277 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 278 
 279 /*
 280  * java.lang.Continuation
 281  */
 282 JNIEXPORT void JNICALL
 283 JVM_RegisterContinuationMethods(JNIEnv *env, jclass cls);
 284 
 285 /*
 286  * java.lang.SecurityManager
 287  */
 288 JNIEXPORT jobjectArray JNICALL
 289 JVM_GetClassContext(JNIEnv *env);
 290 
 291 /*
 292  * java.lang.Package
 293  */
 294 JNIEXPORT jstring JNICALL
 295 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 296 
 297 JNIEXPORT jobjectArray JNICALL
 298 JVM_GetSystemPackages(JNIEnv *env);
 299 
 300 /*
 301  * java.lang.ref.Reference
 302  */
 303 JNIEXPORT jobject JNICALL
 304 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 305 
 306 JNIEXPORT jboolean JNICALL
 307 JVM_HasReferencePendingList(JNIEnv *env);
 308 
 309 JNIEXPORT void JNICALL
 310 JVM_WaitForReferencePendingList(JNIEnv *env);
 311 
 312 /*
 313  * java.io.ObjectInputStream
 314  */
 315 JNIEXPORT jobject JNICALL
 316 JVM_LatestUserDefinedLoader(JNIEnv *env);
 317 
 318 /*
 319  * java.lang.reflect.Array
 320  */
 321 JNIEXPORT jint JNICALL
 322 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 323 
 324 JNIEXPORT jobject JNICALL
 325 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 326 
 327 JNIEXPORT jvalue JNICALL
 328 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 329 
 330 JNIEXPORT void JNICALL
 331 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 332 
 333 JNIEXPORT void JNICALL
 334 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 335                              unsigned char vCode);
 336 
 337 JNIEXPORT jobject JNICALL
 338 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 339 
 340 JNIEXPORT jobject JNICALL
 341 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 342 
 343 
 344 /*
 345  * Returns the immediate caller class of the native method invoking
 346  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 347  * reflection machinery are skipped.
 348  *
 349  * The caller is expected to be marked with
 350  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 351  * error if it is not marked properly.
 352  */
 353 JNIEXPORT jclass JNICALL
 354 JVM_GetCallerClass(JNIEnv *env);
 355 
 356 
 357 /*
 358  * Find primitive classes
 359  * utf: class name
 360  */
 361 JNIEXPORT jclass JNICALL
 362 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 363 
 364 
 365 /*
 366  * Find a class from a boot class loader. Returns NULL if class not found.
 367  */
 368 JNIEXPORT jclass JNICALL
 369 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 370 
 371 /*
 372  * Find a class from a given class loader.  Throws ClassNotFoundException.
 373  *  name:   name of class
 374  *  init:   whether initialization is done
 375  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 376  *          class loader.
 377  *  caller: initiating class. The initiating class may be null when a security
 378  *          manager is not installed.
 379  */
 380 JNIEXPORT jclass JNICALL
 381 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 382                         jobject loader, jclass caller);
 383 
 384 /*
 385  * Find a class from a given class.
 386  */
 387 JNIEXPORT jclass JNICALL
 388 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 389                              jclass from);
 390 
 391 /* Find a loaded class cached by the VM */
 392 JNIEXPORT jclass JNICALL
 393 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 394 
 395 /* Define a class */
 396 JNIEXPORT jclass JNICALL
 397 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 398                 jsize len, jobject pd);
 399 
 400 /* Define a class with a source (added in JDK1.5) */
 401 JNIEXPORT jclass JNICALL
 402 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 403                           const jbyte *buf, jsize len, jobject pd,
 404                           const char *source);
 405 
 406 /*
 407  * Module support funcions
 408  */
 409 
 410 /*
 411  * Define a module with the specified packages and bind the module to the
 412  * given class loader.
 413  *  module:       module to define
 414  *  is_open:      specifies if module is open (currently ignored)
 415  *  version:      the module version
 416  *  location:     the module location
 417  *  packages:     list of packages in the module
 418  *  num_packages: number of packages in the module
 419  */
 420 JNIEXPORT void JNICALL
 421 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 422                  jstring location, const char* const* packages, jsize num_packages);
 423 
 424 /*
 425  * Set the boot loader&#39;s unnamed module.
 426  *  module: boot loader&#39;s unnamed module
 427  */
 428 JNIEXPORT void JNICALL
 429 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 430 
 431 /*
 432  * Do a qualified export of a package.
 433  *  from_module: module containing the package to export
 434  *  package:     name of the package to export
 435  *  to_module:   module to export the package to
 436  */
 437 JNIEXPORT void JNICALL
 438 JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);
 439 
 440 /*
 441  * Do an export of a package to all unnamed modules.
 442  *  from_module: module containing the package to export
 443  *  package:     name of the package to export to all unnamed modules
 444  */
 445 JNIEXPORT void JNICALL
 446 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);
 447 
 448 /*
 449  * Do an unqualified export of a package.
 450  *  from_module: module containing the package to export
 451  *  package:     name of the package to export
 452  */
 453 JNIEXPORT void JNICALL
 454 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);
 455 
 456 /*
 457  * Add a module to the list of modules that a given module can read.
 458  *  from_module:   module requesting read access
 459  *  source_module: module that from_module wants to read
 460  */
 461 JNIEXPORT void JNICALL
 462 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 463 
 464 /*
 465  * Reflection support functions
 466  */
 467 
 468 JNIEXPORT jstring JNICALL
 469 JVM_InitClassName(JNIEnv *env, jclass cls);
 470 
 471 JNIEXPORT jobjectArray JNICALL
 472 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 473 
 474 JNIEXPORT jboolean JNICALL
 475 JVM_IsInterface(JNIEnv *env, jclass cls);
 476 
 477 JNIEXPORT jobjectArray JNICALL
 478 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 479 
 480 JNIEXPORT void JNICALL
 481 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 482 
 483 JNIEXPORT jobject JNICALL
 484 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 485 
 486 JNIEXPORT jboolean JNICALL
 487 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 488 
 489 JNIEXPORT jboolean JNICALL
 490 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 491 
 492 JNIEXPORT jint JNICALL
 493 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 494 
 495 JNIEXPORT jobjectArray JNICALL
 496 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 497 
 498 JNIEXPORT jclass JNICALL
 499 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 500 
 501 JNIEXPORT jstring JNICALL
 502 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 503 
 504 /* Generics support (JDK 1.5) */
 505 JNIEXPORT jstring JNICALL
 506 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 507 
 508 /* Annotations support (JDK 1.5) */
 509 JNIEXPORT jbyteArray JNICALL
 510 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 511 
 512 /* Type use annotations support (JDK 1.8) */
 513 
 514 JNIEXPORT jbyteArray JNICALL
 515 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 516 
 517 JNIEXPORT jbyteArray JNICALL
 518 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 519 
 520 JNIEXPORT jbyteArray JNICALL
 521 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 522 
 523 /*
 524  * New (JDK 1.4) reflection implementation
 525  */
 526 
 527 JNIEXPORT jobjectArray JNICALL
 528 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 529 
 530 JNIEXPORT jobjectArray JNICALL
 531 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 532 
 533 JNIEXPORT jobjectArray JNICALL
 534 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 535 
 536 
 537 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 538    This returns the access flags for the class as specified in the
 539    class file rather than searching the InnerClasses attribute (if
 540    present) to find the source-level access flags. Only the values of
 541    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 542    valid. */
 543 JNIEXPORT jint JNICALL
 544 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 545 
 546 /* Nestmates - since JDK 11 */
 547 
 548 JNIEXPORT jboolean JNICALL
 549 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 550 
 551 JNIEXPORT jclass JNICALL
 552 JVM_GetNestHost(JNIEnv *env, jclass current);
 553 
 554 JNIEXPORT jobjectArray JNICALL
 555 JVM_GetNestMembers(JNIEnv *env, jclass current);
 556 
 557 /* Records - since JDK 14 */
 558 
 559 JNIEXPORT jboolean JNICALL
 560 JVM_IsRecord(JNIEnv *env, jclass cls);
 561 
 562 JNIEXPORT jobjectArray JNICALL
 563 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 564 
 565 /* The following two reflection routines are still needed due to startup time issues */
 566 /*
 567  * java.lang.reflect.Method
 568  */
 569 JNIEXPORT jobject JNICALL
 570 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 571 
 572 /*
 573  * java.lang.reflect.Constructor
 574  */
 575 JNIEXPORT jobject JNICALL
 576 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 577 
 578 /*
 579  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 580  */
 581 
 582 JNIEXPORT jobject JNICALL
 583 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 584 
 585 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 586 (JNIEnv *env, jobject unused, jobject jcpool);
 587 
 588 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 589 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 590 
 591 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 592 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 593 
 594 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 595 (JNIEnv *env, jobject obj, jobject unused, jint index);
 596 
 597 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 598 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 599 
 600 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 601 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 602 
 603 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 604 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 605 
 606 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 607 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 608 
 609 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 610 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 611 
 612 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 613 (JNIEnv *env, jobject obj, jobject unused, jint index);
 614 
 615 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 616 (JNIEnv *env, jobject obj, jobject unused, jint index);
 617 
 618 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 619 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 620 
 621 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 622 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 623 
 624 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 625 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 626 
 627 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 628 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 629 
 630 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 631 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 632 
 633 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 634 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 635 
 636 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 637 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 638 
 639 /*
 640  * Parameter reflection
 641  */
 642 
 643 JNIEXPORT jobjectArray JNICALL
 644 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 645 
 646 /*
 647  * java.security.*
 648  */
 649 
 650 JNIEXPORT jobject JNICALL
 651 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 652 
 653 /*
 654  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 655  * get the value will see a materialized value and not a scalar-replaced
 656  * null value.
 657  */
 658 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 659     do {} while(0) // Nothing to do.  The fact that the value escaped
 660                    // through a native method is enough.
 661 
 662 JNIEXPORT jobject JNICALL
 663 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 664 
 665 /*
 666  * Signal support, used to implement the shutdown sequence.  Every VM must
 667  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 668  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 669  * Other platform-dependent signal values may also be supported.
 670  */
 671 
 672 JNIEXPORT void * JNICALL
 673 JVM_RegisterSignal(jint sig, void *handler);
 674 
 675 JNIEXPORT jboolean JNICALL
 676 JVM_RaiseSignal(jint sig);
 677 
 678 JNIEXPORT jint JNICALL
 679 JVM_FindSignal(const char *name);
 680 
 681 /*
 682  * Retrieve the assertion directives for the specified class.
 683  */
 684 JNIEXPORT jboolean JNICALL
 685 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 686 
 687 /*
 688  * Retrieve the assertion directives from the VM.
 689  */
 690 JNIEXPORT jobject JNICALL
 691 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 692 
 693 /*
 694  * java.util.concurrent.atomic.AtomicLong
 695  */
 696 JNIEXPORT jboolean JNICALL
 697 JVM_SupportsCX8(void);
 698 
 699 /*
 700  * com.sun.dtrace.jsdt support
 701  */
 702 
 703 #define JVM_TRACING_DTRACE_VERSION 1
 704 
 705 /*
 706  * Structure to pass one probe description to JVM
 707  */
 708 typedef struct {
 709     jmethodID method;
 710     jstring   function;
 711     jstring   name;
 712     void*            reserved[4];     // for future use
 713 } JVM_DTraceProbe;
 714 
 715 /**
 716  * Encapsulates the stability ratings for a DTrace provider field
 717  */
 718 typedef struct {
 719     jint nameStability;
 720     jint dataStability;
 721     jint dependencyClass;
 722 } JVM_DTraceInterfaceAttributes;
 723 
 724 /*
 725  * Structure to pass one provider description to JVM
 726  */
 727 typedef struct {
 728     jstring                       name;
 729     JVM_DTraceProbe*              probes;
 730     jint                          probe_count;
 731     JVM_DTraceInterfaceAttributes providerAttributes;
 732     JVM_DTraceInterfaceAttributes moduleAttributes;
 733     JVM_DTraceInterfaceAttributes functionAttributes;
 734     JVM_DTraceInterfaceAttributes nameAttributes;
 735     JVM_DTraceInterfaceAttributes argsAttributes;
 736     void*                         reserved[4]; // for future use
 737 } JVM_DTraceProvider;
 738 
 739 /*
 740  * Get the version number the JVM was built with
 741  */
 742 JNIEXPORT jint JNICALL
 743 JVM_DTraceGetVersion(JNIEnv* env);
 744 
 745 /*
 746  * Register new probe with given signature, return global handle
 747  *
 748  * The version passed in is the version that the library code was
 749  * built with.
 750  */
 751 JNIEXPORT jlong JNICALL
 752 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 753   jint providers_count, JVM_DTraceProvider* providers);
 754 
 755 /*
 756  * Check JSDT probe
 757  */
 758 JNIEXPORT jboolean JNICALL
 759 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 760 
 761 /*
 762  * Destroy custom DOF
 763  */
 764 JNIEXPORT void JNICALL
 765 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 766 
 767 /*
 768  * Check to see if DTrace is supported by OS
 769  */
 770 JNIEXPORT jboolean JNICALL
 771 JVM_DTraceIsSupported(JNIEnv* env);
 772 
 773 /*************************************************************************
 774  PART 2: Support for the Verifier and Class File Format Checker
 775  ************************************************************************/
 776 /*
 777  * Return the class name in UTF format. The result is valid
 778  * until JVM_ReleaseUTf is called.
 779  *
 780  * The caller must treat the string as a constant and not modify it
 781  * in any way.
 782  */
 783 JNIEXPORT const char * JNICALL
 784 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 785 
 786 /*
 787  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 788  */
 789 JNIEXPORT void JNICALL
 790 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 791 
 792 /*
 793  * Returns the number of Constant Pool entries.
 794  */
 795 JNIEXPORT jint JNICALL
 796 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 797 
 798 /*
 799  * Returns the number of *declared* fields or methods.
 800  */
 801 JNIEXPORT jint JNICALL
 802 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 803 
 804 JNIEXPORT jint JNICALL
 805 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 806 
 807 /*
 808  * Returns the CP indexes of exceptions raised by a given method.
 809  * Places the result in the given buffer.
 810  *
 811  * The method is identified by method_index.
 812  */
 813 JNIEXPORT void JNICALL
 814 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 815                                 unsigned short *exceptions);
 816 /*
 817  * Returns the number of exceptions raised by a given method.
 818  * The method is identified by method_index.
 819  */
 820 JNIEXPORT jint JNICALL
 821 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 822 
 823 /*
 824  * Returns the byte code sequence of a given method.
 825  * Places the result in the given buffer.
 826  *
 827  * The method is identified by method_index.
 828  */
 829 JNIEXPORT void JNICALL
 830 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 831                         unsigned char *code);
 832 
 833 /*
 834  * Returns the length of the byte code sequence of a given method.
 835  * The method is identified by method_index.
 836  */
 837 JNIEXPORT jint JNICALL
 838 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 839 
 840 /*
 841  * A structure used to a capture exception table entry in a Java method.
 842  */
 843 typedef struct {
 844     jint start_pc;
 845     jint end_pc;
 846     jint handler_pc;
 847     jint catchType;
 848 } JVM_ExceptionTableEntryType;
 849 
 850 /*
 851  * Returns the exception table entry at entry_index of a given method.
 852  * Places the result in the given buffer.
 853  *
 854  * The method is identified by method_index.
 855  */
 856 JNIEXPORT void JNICALL
 857 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 858                                    jint entry_index,
 859                                    JVM_ExceptionTableEntryType *entry);
 860 
 861 /*
 862  * Returns the length of the exception table of a given method.
 863  * The method is identified by method_index.
 864  */
 865 JNIEXPORT jint JNICALL
 866 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 867 
 868 /*
 869  * Returns the modifiers of a given field.
 870  * The field is identified by field_index.
 871  */
 872 JNIEXPORT jint JNICALL
 873 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 874 
 875 /*
 876  * Returns the modifiers of a given method.
 877  * The method is identified by method_index.
 878  */
 879 JNIEXPORT jint JNICALL
 880 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 881 
 882 /*
 883  * Returns the number of local variables of a given method.
 884  * The method is identified by method_index.
 885  */
 886 JNIEXPORT jint JNICALL
 887 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 888 
 889 /*
 890  * Returns the number of arguments (including this pointer) of a given method.
 891  * The method is identified by method_index.
 892  */
 893 JNIEXPORT jint JNICALL
 894 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 895 
 896 /*
 897  * Returns the maximum amount of stack (in words) used by a given method.
 898  * The method is identified by method_index.
 899  */
 900 JNIEXPORT jint JNICALL
 901 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 902 
 903 /*
 904  * Is a given method a constructor.
 905  * The method is identified by method_index.
 906  */
 907 JNIEXPORT jboolean JNICALL
 908 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 909 
 910 /*
 911  * Is the given method generated by the VM.
 912  * The method is identified by method_index.
 913  */
 914 JNIEXPORT jboolean JNICALL
 915 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 916 
 917 /*
 918  * Returns the name of a given method in UTF format.
 919  * The result remains valid until JVM_ReleaseUTF is called.
 920  *
 921  * The caller must treat the string as a constant and not modify it
 922  * in any way.
 923  */
 924 JNIEXPORT const char * JNICALL
 925 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 926 
 927 /*
 928  * Returns the signature of a given method in UTF format.
 929  * The result remains valid until JVM_ReleaseUTF is called.
 930  *
 931  * The caller must treat the string as a constant and not modify it
 932  * in any way.
 933  */
 934 JNIEXPORT const char * JNICALL
 935 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 936 
 937 /*
 938  * Returns the name of the field referred to at a given constant pool
 939  * index.
 940  *
 941  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 942  * is called.
 943  *
 944  * The caller must treat the string as a constant and not modify it
 945  * in any way.
 946  */
 947 JNIEXPORT const char * JNICALL
 948 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 949 
 950 /*
 951  * Returns the name of the method referred to at a given constant pool
 952  * index.
 953  *
 954  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 955  * is called.
 956  *
 957  * The caller must treat the string as a constant and not modify it
 958  * in any way.
 959  */
 960 JNIEXPORT const char * JNICALL
 961 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 962 
 963 /*
 964  * Returns the signature of the method referred to at a given constant pool
 965  * index.
 966  *
 967  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 968  * is called.
 969  *
 970  * The caller must treat the string as a constant and not modify it
 971  * in any way.
 972  */
 973 JNIEXPORT const char * JNICALL
 974 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 975 
 976 /*
 977  * Returns the signature of the field referred to at a given constant pool
 978  * index.
 979  *
 980  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 981  * is called.
 982  *
 983  * The caller must treat the string as a constant and not modify it
 984  * in any way.
 985  */
 986 JNIEXPORT const char * JNICALL
 987 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 988 
 989 /*
 990  * Returns the class name referred to at a given constant pool index.
 991  *
 992  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 993  * is called.
 994  *
 995  * The caller must treat the string as a constant and not modify it
 996  * in any way.
 997  */
 998 JNIEXPORT const char * JNICALL
 999 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
1000 
1001 /*
1002  * Returns the class name referred to at a given constant pool index.
1003  *
1004  * The constant pool entry must refer to a CONSTANT_Fieldref.
1005  *
1006  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1007  * is called.
1008  *
1009  * The caller must treat the string as a constant and not modify it
1010  * in any way.
1011  */
1012 JNIEXPORT const char * JNICALL
1013 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1014 
1015 /*
1016  * Returns the class name referred to at a given constant pool index.
1017  *
1018  * The constant pool entry must refer to CONSTANT_Methodref or
1019  * CONSTANT_InterfaceMethodref.
1020  *
1021  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1022  * is called.
1023  *
1024  * The caller must treat the string as a constant and not modify it
1025  * in any way.
1026  */
1027 JNIEXPORT const char * JNICALL
1028 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1029 
1030 /*
1031  * Returns the modifiers of a field in calledClass. The field is
1032  * referred to in class cb at constant pool entry index.
1033  *
1034  * The caller must treat the string as a constant and not modify it
1035  * in any way.
1036  *
1037  * Returns -1 if the field does not exist in calledClass.
1038  */
1039 JNIEXPORT jint JNICALL
1040 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1041 
1042 /*
1043  * Returns the modifiers of a method in calledClass. The method is
1044  * referred to in class cb at constant pool entry index.
1045  *
1046  * Returns -1 if the method does not exist in calledClass.
1047  */
1048 JNIEXPORT jint JNICALL
1049 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1050 
1051 /*
1052  * Releases the UTF string obtained from the VM.
1053  */
1054 JNIEXPORT void JNICALL
1055 JVM_ReleaseUTF(const char *utf);
1056 
1057 /*
1058  * Compare if two classes are in the same package.
1059  */
1060 JNIEXPORT jboolean JNICALL
1061 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1062 
1063 /* Get classfile constants */
1064 #include &quot;classfile_constants.h&quot;
1065 
1066 /*
1067  * Support for a VM-independent class format checker.
1068  */
1069 typedef struct {
1070     unsigned long code;    /* byte code */
1071     unsigned long excs;    /* exceptions */
1072     unsigned long etab;    /* catch table */
1073     unsigned long lnum;    /* line number */
1074     unsigned long lvar;    /* local vars */
1075 } method_size_info;
1076 
1077 typedef struct {
1078     unsigned int constants;    /* constant pool */
1079     unsigned int fields;
1080     unsigned int methods;
1081     unsigned int interfaces;
1082     unsigned int fields2;      /* number of static 2-word fields */
1083     unsigned int innerclasses; /* # of records in InnerClasses attr */
1084 
1085     method_size_info clinit;   /* memory used in clinit */
1086     method_size_info main;     /* used everywhere else */
1087 } class_size_info;
1088 
1089 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1090                                         JVM_ACC_FINAL | \
1091                                         JVM_ACC_SUPER | \
1092                                         JVM_ACC_INTERFACE | \
1093                                         JVM_ACC_ABSTRACT | \
1094                                         JVM_ACC_ANNOTATION | \
1095                                         JVM_ACC_ENUM | \
1096                                         JVM_ACC_SYNTHETIC)
1097 
1098 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1099                                         JVM_ACC_PRIVATE | \
1100                                         JVM_ACC_PROTECTED | \
1101                                         JVM_ACC_STATIC | \
1102                                         JVM_ACC_FINAL | \
1103                                         JVM_ACC_VOLATILE | \
1104                                         JVM_ACC_TRANSIENT | \
1105                                         JVM_ACC_ENUM | \
1106                                         JVM_ACC_SYNTHETIC)
1107 
1108 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1109                                          JVM_ACC_PRIVATE | \
1110                                          JVM_ACC_PROTECTED | \
1111                                          JVM_ACC_STATIC | \
1112                                          JVM_ACC_FINAL | \
1113                                          JVM_ACC_SYNCHRONIZED | \
1114                                          JVM_ACC_BRIDGE | \
1115                                          JVM_ACC_VARARGS | \
1116                                          JVM_ACC_NATIVE | \
1117                                          JVM_ACC_ABSTRACT | \
1118                                          JVM_ACC_STRICT | \
1119                                          JVM_ACC_SYNTHETIC)
1120 
1121 
1122 /*************************************************************************
1123  PART 3: I/O and Network Support
1124  ************************************************************************/
1125 
1126 /*
1127  * Convert a pathname into native format.  This function does syntactic
1128  * cleanup, such as removing redundant separator characters.  It modifies
1129  * the given pathname string in place.
1130  */
1131 JNIEXPORT char * JNICALL
1132 JVM_NativePath(char *);
1133 
1134 /*
1135  * The standard printing functions supported by the Java VM. (Should they
1136  * be renamed to JVM_* in the future?
1137  */
1138 
1139 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1140  *  respectively, with the following differences:
1141  * - The string written to str is always zero-terminated, also in case of
1142  *   truncation (count is too small to hold the result string), unless count
1143  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1144  *   appendend.
1145  * - If count is too small to hold the whole string, -1 is returned across
1146  *   all platforms. */
1147 
1148 JNIEXPORT int
1149 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1150 
1151 JNIEXPORT int
1152 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1153 
1154 JNIEXPORT int
1155 jio_fprintf(FILE *, const char *fmt, ...);
1156 
1157 JNIEXPORT int
1158 jio_vfprintf(FILE *, const char *fmt, va_list args);
1159 
1160 
1161 JNIEXPORT void * JNICALL
1162 JVM_RawMonitorCreate(void);
1163 
1164 JNIEXPORT void JNICALL
1165 JVM_RawMonitorDestroy(void *mon);
1166 
1167 JNIEXPORT jint JNICALL
1168 JVM_RawMonitorEnter(void *mon);
1169 
1170 JNIEXPORT void JNICALL
1171 JVM_RawMonitorExit(void *mon);
1172 
1173 /*
1174  * java.lang.management support
1175  */
1176 JNIEXPORT void* JNICALL
1177 JVM_GetManagement(jint version);
1178 
1179 /*
1180  * com.sun.tools.attach.VirtualMachine support
1181  *
1182  * Initialize the agent properties with the properties maintained in the VM.
1183  */
1184 JNIEXPORT jobject JNICALL
1185 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1186 
1187 JNIEXPORT jstring JNICALL
1188 JVM_GetTemporaryDirectory(JNIEnv *env);
1189 
1190 /* Generics reflection support.
1191  *
1192  * Returns information about the given class&#39;s EnclosingMethod
1193  * attribute, if present, or null if the class had no enclosing
1194  * method.
1195  *
1196  * If non-null, the returned array contains three elements. Element 0
1197  * is the java.lang.Class of which the enclosing method is a member,
1198  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1199  * method&#39;s name and descriptor, respectively.
1200  */
1201 JNIEXPORT jobjectArray JNICALL
1202 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1203     
1204 /* Virtual thread support.
1205  */
1206 JNIEXPORT void JNICALL
1207 JVM_VirtualThreadStarted(JNIEnv* env, jclass vthread_class, jobject event_thread, jobject vthread);
1208 
1209 JNIEXPORT void JNICALL
1210 JVM_VirtualThreadTerminated(JNIEnv* env, jclass vthread_class, jobject event_hread, jobject vthread);
1211 
1212 JNIEXPORT void JNICALL
1213 JVM_VirtualThreadMount(JNIEnv* env, jclass vthread_class, jobject event_thread, jobject vthread);
1214 
1215 JNIEXPORT void JNICALL
1216 JVM_VirtualThreadUnmount(JNIEnv* env, jclass vthread_class, jobject event_hread, jobject vthread);
1217 
1218 /*
1219  * This structure is used by the launcher to get the default thread
1220  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1221  * version of 1.1.  As it is not supported otherwise, it has been removed
1222  * from jni.h
1223  */
1224 typedef struct JDK1_1InitArgs {
1225     jint version;
1226 
1227     char **properties;
1228     jint checkSource;
1229     jint nativeStackSize;
1230     jint javaStackSize;
1231     jint minHeapSize;
1232     jint maxHeapSize;
1233     jint verifyMode;
1234     char *classpath;
1235 
1236     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1237     void (JNICALL *exit)(jint code);
1238     void (JNICALL *abort)(void);
1239 
1240     jint enableClassGC;
1241     jint enableVerboseGC;
1242     jint disableAsyncGC;
1243     jint verbose;
1244     jboolean debugging;
1245     jint debugPort;
1246 } JDK1_1InitArgs;
1247 
1248 
1249 #ifdef __cplusplus
1250 } /* extern &quot;C&quot; */
1251 
1252 #endif /* __cplusplus */
1253 
1254 #endif /* !_JAVASOFT_JVM_H_ */
    </pre>
  </body>
</html>